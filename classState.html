<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bluenet: State Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
	DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bluenet
   &#160;<span id="projectnumber">5.4.0</span>
   </div>
   <div id="projectbrief">Bluenet, the firmware for the Crownstone power outlet</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classState.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classState-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">State Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Stores state values in RAM and/or FLASH.  
 <a href="classState.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cs__State_8h_source.html">cs_State.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for State:</div>
<div class="dyncontent">
<div class="center"><img src="classState__inherit__graph.png" border="0" usemap="#aState_inherit__map" alt="Inheritance graph"/></div>
<map name="aState_inherit__map" id="aState_inherit__map">
<area shape="rect" title="Stores state values in RAM and/or FLASH." alt="" coords="114,79,170,104"/>
<area shape="rect" href="classBaseClass.html" title="BaseClass." alt="" coords="5,5,135,31"/>
<area shape="rect" href="classEventListener.html" title="Event listener." alt="" coords="159,5,269,31"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for State:</div>
<div class="dyncontent">
<div class="center"><img src="classState__coll__graph.png" border="0" usemap="#aState_coll__map" alt="Collaboration graph"/></div>
<map name="aState_coll__map" id="aState_coll__map">
<area shape="rect" title="Stores state values in RAM and/or FLASH." alt="" coords="243,93,299,119"/>
<area shape="rect" href="classBaseClass.html" title="BaseClass." alt="" coords="5,5,135,31"/>
<area shape="rect" href="classEventListener.html" title="Event listener." alt="" coords="159,5,269,31"/>
<area shape="rect" href="classStorage.html" title="Class to store items persistently in flash (persistent) memory." alt="" coords="294,5,366,31"/>
<area shape="rect" href="structboards__config__t.html" title="Board configuration." alt="" coords="390,5,515,31"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad37d1373fa95b45718ff471799dfc067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#ad37d1373fa95b45718ff471799dfc067">init</a> (<a class="el" href="structboards__config__t.html">boards_config_t</a> *boardsConfig)</td></tr>
<tr class="memdesc:ad37d1373fa95b45718ff471799dfc067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> object with the board configuration.  <a href="classState.html#ad37d1373fa95b45718ff471799dfc067">More...</a><br /></td></tr>
<tr class="separator:ad37d1373fa95b45718ff471799dfc067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a02973119b3d6fd68ed47fbcac198e6"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a5a02973119b3d6fd68ed47fbcac198e6">get</a> (<a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data, const PersistenceMode mode=PersistenceMode::STRATEGY1)</td></tr>
<tr class="memdesc:a5a02973119b3d6fd68ed47fbcac198e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get copy of a state value.  <a href="classState.html#a5a02973119b3d6fd68ed47fbcac198e6">More...</a><br /></td></tr>
<tr class="separator:a5a02973119b3d6fd68ed47fbcac198e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63baa15ae12ca1d3b009bf908c65ad73"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a63baa15ae12ca1d3b009bf908c65ad73">get</a> (const CS_TYPE type, void *value, size16_t size)</td></tr>
<tr class="memdesc:a63baa15ae12ca1d3b009bf908c65ad73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for <a class="el" href="classState.html#a5a02973119b3d6fd68ed47fbcac198e6" title="Get copy of a state value.">get()</a> with id 0.  <a href="classState.html#a63baa15ae12ca1d3b009bf908c65ad73">More...</a><br /></td></tr>
<tr class="separator:a63baa15ae12ca1d3b009bf908c65ad73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af808c9d5d864e8a9459bc1617f6cdb1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#af808c9d5d864e8a9459bc1617f6cdb1a">isTrue</a> (CS_TYPE type, const PersistenceMode mode=PersistenceMode::STRATEGY1)</td></tr>
<tr class="memdesc:af808c9d5d864e8a9459bc1617f6cdb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="classState.html#a5a02973119b3d6fd68ed47fbcac198e6" title="Get copy of a state value.">get()</a> for boolean data types, and id 0.  <a href="classState.html#af808c9d5d864e8a9459bc1617f6cdb1a">More...</a><br /></td></tr>
<tr class="separator:af808c9d5d864e8a9459bc1617f6cdb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36a79c4643010cc2adf73a75b8447fb"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#ae36a79c4643010cc2adf73a75b8447fb">getIds</a> (CS_TYPE type, std::vector&lt; cs_state_id_t &gt; *&amp;ids)</td></tr>
<tr class="memdesc:ae36a79c4643010cc2adf73a75b8447fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of IDs for given type.  <a href="classState.html#ae36a79c4643010cc2adf73a75b8447fb">More...</a><br /></td></tr>
<tr class="separator:ae36a79c4643010cc2adf73a75b8447fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8451f4870511d24e4fe931c1cf4d6246"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a8451f4870511d24e4fe931c1cf4d6246">set</a> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data, PersistenceMode mode=PersistenceMode::STRATEGY1)</td></tr>
<tr class="memdesc:a8451f4870511d24e4fe931c1cf4d6246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set state to new value, via copy.  <a href="classState.html#a8451f4870511d24e4fe931c1cf4d6246">More...</a><br /></td></tr>
<tr class="separator:a8451f4870511d24e4fe931c1cf4d6246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f411b0baa1244bd3202502dc9a44bd7"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a3f411b0baa1244bd3202502dc9a44bd7">set</a> (const CS_TYPE type, void *value, size16_t size)</td></tr>
<tr class="memdesc:a3f411b0baa1244bd3202502dc9a44bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for <a class="el" href="classState.html#a8451f4870511d24e4fe931c1cf4d6246" title="Set state to new value, via copy.">set()</a>.  <a href="classState.html#a3f411b0baa1244bd3202502dc9a44bd7">More...</a><br /></td></tr>
<tr class="separator:a3f411b0baa1244bd3202502dc9a44bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cff7fd1b35b70a093ccfa4f5829769"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a42cff7fd1b35b70a093ccfa4f5829769">setDelayed</a> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data, uint8_t delay)</td></tr>
<tr class="memdesc:a42cff7fd1b35b70a093ccfa4f5829769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state to a new value, but delay the write to flash.  <a href="classState.html#a42cff7fd1b35b70a093ccfa4f5829769">More...</a><br /></td></tr>
<tr class="separator:a42cff7fd1b35b70a093ccfa4f5829769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37d56e82b944fa5cc8bce060ebd2ff6"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#ad37d56e82b944fa5cc8bce060ebd2ff6">setThrottled</a> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data, uint32_t period)</td></tr>
<tr class="memdesc:ad37d56e82b944fa5cc8bce060ebd2ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write variable to flash in a throttled mode.  <a href="classState.html#ad37d56e82b944fa5cc8bce060ebd2ff6">More...</a><br /></td></tr>
<tr class="separator:ad37d56e82b944fa5cc8bce060ebd2ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d963b9f6ade3b8662e1ff0062e27708"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a6d963b9f6ade3b8662e1ff0062e27708">verifySizeForGet</a> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a6d963b9f6ade3b8662e1ff0062e27708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify size of user data for getting a state.  <a href="classState.html#a6d963b9f6ade3b8662e1ff0062e27708">More...</a><br /></td></tr>
<tr class="separator:a6d963b9f6ade3b8662e1ff0062e27708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d2af69aaa0380f678f138be0618e02"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a46d2af69aaa0380f678f138be0618e02">verifySizeForSet</a> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a46d2af69aaa0380f678f138be0618e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify size of user data for setting a state.  <a href="classState.html#a46d2af69aaa0380f678f138be0618e02">More...</a><br /></td></tr>
<tr class="separator:a46d2af69aaa0380f678f138be0618e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad477ee685332e4424e80848abdae1412"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#ad477ee685332e4424e80848abdae1412">remove</a> (const CS_TYPE &amp;type, cs_state_id_t id, const PersistenceMode mode=PersistenceMode::STRATEGY1)</td></tr>
<tr class="memdesc:ad477ee685332e4424e80848abdae1412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a state variable.  <a href="classState.html#ad477ee685332e4424e80848abdae1412">More...</a><br /></td></tr>
<tr class="separator:ad477ee685332e4424e80848abdae1412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f0c54230e8b920fa430e97906894fc"><td class="memItemLeft" align="right" valign="top"><a id="ab6f0c54230e8b920fa430e97906894fc" name="ab6f0c54230e8b920fa430e97906894fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>factoryReset</b> ()</td></tr>
<tr class="memdesc:ab6f0c54230e8b920fa430e97906894fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all used persistent storage. <br /></td></tr>
<tr class="separator:ab6f0c54230e8b920fa430e97906894fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f122ed63d6c04b8aba8e27e0f5249fe"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a4f122ed63d6c04b8aba8e27e0f5249fe">cleanUp</a> ()</td></tr>
<tr class="memdesc:a4f122ed63d6c04b8aba8e27e0f5249fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up persistent storage.  <a href="classState.html#a4f122ed63d6c04b8aba8e27e0f5249fe">More...</a><br /></td></tr>
<tr class="separator:a4f122ed63d6c04b8aba8e27e0f5249fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1759335a4b5529aff8a9221db3d35559"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a1759335a4b5529aff8a9221db3d35559">getViaPointer</a> (<a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data, const PersistenceMode mode=PersistenceMode::STRATEGY1)</td></tr>
<tr class="memdesc:a1759335a4b5529aff8a9221db3d35559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to state value.  <a href="classState.html#a1759335a4b5529aff8a9221db3d35559">More...</a><br /></td></tr>
<tr class="separator:a1759335a4b5529aff8a9221db3d35559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80421b79db2b144889db602e12a39ef"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#aa80421b79db2b144889db602e12a39ef">setViaPointer</a> (CS_TYPE type)</td></tr>
<tr class="memdesc:aa80421b79db2b144889db602e12a39ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update state value.  <a href="classState.html#aa80421b79db2b144889db602e12a39ef">More...</a><br /></td></tr>
<tr class="separator:aa80421b79db2b144889db602e12a39ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f85d6f2813360b7c4e65078d324a9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a31f85d6f2813360b7c4e65078d324a9e">startWritesToFlash</a> ()</td></tr>
<tr class="memdesc:a31f85d6f2813360b7c4e65078d324a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">After calling this, state is allowed to write to flash.  <a href="classState.html#a31f85d6f2813360b7c4e65078d324a9e">More...</a><br /></td></tr>
<tr class="separator:a31f85d6f2813360b7c4e65078d324a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b6e94c27167ef4ae1be2436f0f7805"><td class="memItemLeft" align="right" valign="top"><a id="a85b6e94c27167ef4ae1be2436f0f7805" name="a85b6e94c27167ef4ae1be2436f0f7805"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>handleStorageError</b> (cs_storage_operation_t operation, CS_TYPE type, cs_state_id_t id)</td></tr>
<tr class="memdesc:a85b6e94c27167ef4ae1be2436f0f7805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal usage. <br /></td></tr>
<tr class="separator:a85b6e94c27167ef4ae1be2436f0f7805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7669e3e5afe2e3280630d785afc9ef34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a7669e3e5afe2e3280630d785afc9ef34">handleEvent</a> (<a class="el" href="classevent__t.html">event_t</a> &amp;event)</td></tr>
<tr class="memdesc:a7669e3e5afe2e3280630d785afc9ef34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle (crownstone) events.  <a href="classState.html#a7669e3e5afe2e3280630d785afc9ef34">More...</a><br /></td></tr>
<tr class="separator:a7669e3e5afe2e3280630d785afc9ef34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classBaseClass"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classBaseClass')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classBaseClass.html">BaseClass&lt; N &gt;</a></td></tr>
<tr class="memitem:a9e2337c2676bf9fbcca00ab7750bbf14 inherit pub_methods_classBaseClass"><td class="memItemLeft" align="right" valign="top"><a id="a9e2337c2676bf9fbcca00ab7750bbf14" name="a9e2337c2676bf9fbcca00ab7750bbf14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInitialized</b> (uint8_t i=0)</td></tr>
<tr class="separator:a9e2337c2676bf9fbcca00ab7750bbf14 inherit pub_methods_classBaseClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0290904b966a159231f848cfb5fd97a4 inherit pub_methods_classBaseClass"><td class="memItemLeft" align="right" valign="top"><a id="a0290904b966a159231f848cfb5fd97a4" name="a0290904b966a159231f848cfb5fd97a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setInitialized</b> (uint8_t i=0)</td></tr>
<tr class="separator:a0290904b966a159231f848cfb5fd97a4 inherit pub_methods_classBaseClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4391d2f80e021fc4420fb48278a314ae inherit pub_methods_classBaseClass"><td class="memItemLeft" align="right" valign="top"><a id="a4391d2f80e021fc4420fb48278a314ae" name="a4391d2f80e021fc4420fb48278a314ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setUninitialized</b> (uint8_t i=0)</td></tr>
<tr class="separator:a4391d2f80e021fc4420fb48278a314ae inherit pub_methods_classBaseClass"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad18d563a732ed9d6659d6b38492f89dc"><td class="memItemLeft" align="right" valign="top"><a id="ad18d563a732ed9d6659d6b38492f89dc" name="ad18d563a732ed9d6659d6b38492f89dc"></a>
static <a class="el" href="classState.html">State</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getInstance</b> ()</td></tr>
<tr class="memdesc:ad18d563a732ed9d6659d6b38492f89dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the <a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> object. <br /></td></tr>
<tr class="separator:ad18d563a732ed9d6659d6b38492f89dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a32a47427f426acbdc17d35eefe111890"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a32a47427f426acbdc17d35eefe111890">findInRam</a> (const CS_TYPE &amp;type, cs_state_id_t id, size16_t &amp;index_in_ram)</td></tr>
<tr class="memdesc:a32a47427f426acbdc17d35eefe111890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find given type in ram.  <a href="classState.html#a32a47427f426acbdc17d35eefe111890">More...</a><br /></td></tr>
<tr class="separator:a32a47427f426acbdc17d35eefe111890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8f20fff6d3e4206999d9731f6fa607"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a0f8f20fff6d3e4206999d9731f6fa607">storeInRam</a> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data, size16_t &amp;index_in_ram)</td></tr>
<tr class="memdesc:a0f8f20fff6d3e4206999d9731f6fa607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores state variable in ram.  <a href="classState.html#a0f8f20fff6d3e4206999d9731f6fa607">More...</a><br /></td></tr>
<tr class="separator:a0f8f20fff6d3e4206999d9731f6fa607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f586f7d62690af97d138a6703129d9"><td class="memItemLeft" align="right" valign="top"><a id="ad2f586f7d62690af97d138a6703129d9" name="ad2f586f7d62690af97d138a6703129d9"></a>
cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><b>storeInRam</b> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:ad2f586f7d62690af97d138a6703129d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function, in case you're not interested in index in ram. <br /></td></tr>
<tr class="separator:ad2f586f7d62690af97d138a6703129d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d45df4e62a87a10b5cc854b9bad1236"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a0d45df4e62a87a10b5cc854b9bad1236">loadFromRam</a> (<a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a0d45df4e62a87a10b5cc854b9bad1236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from ram to target buffer.  <a href="classState.html#a0d45df4e62a87a10b5cc854b9bad1236">More...</a><br /></td></tr>
<tr class="separator:a0d45df4e62a87a10b5cc854b9bad1236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42147d96fff13879450686937c7a1a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a42147d96fff13879450686937c7a1a93">addToRam</a> (const CS_TYPE &amp;type, cs_state_id_t id, size16_t size)</td></tr>
<tr class="memdesc:a42147d96fff13879450686937c7a1a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new state_data struct to ram.  <a href="classState.html#a42147d96fff13879450686937c7a1a93">More...</a><br /></td></tr>
<tr class="separator:a42147d96fff13879450686937c7a1a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92388d397775a8af4318403e33972fad"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a92388d397775a8af4318403e33972fad">removeFromRam</a> (const CS_TYPE &amp;type, cs_state_id_t id)</td></tr>
<tr class="memdesc:a92388d397775a8af4318403e33972fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removed a state variable from ram.  <a href="classState.html#a92388d397775a8af4318403e33972fad">More...</a><br /></td></tr>
<tr class="separator:a92388d397775a8af4318403e33972fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b62ec4b0cff5f5e7a4446a5c19877b"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#ac3b62ec4b0cff5f5e7a4446a5c19877b">compareWithRam</a> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data, uint32_t &amp;cmp_result)</td></tr>
<tr class="memdesc:ac3b62ec4b0cff5f5e7a4446a5c19877b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a particular value with the value currently in ram.  <a href="classState.html#ac3b62ec4b0cff5f5e7a4446a5c19877b">More...</a><br /></td></tr>
<tr class="separator:ac3b62ec4b0cff5f5e7a4446a5c19877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b9ba4bfcd10dc3dfaf919cbb610339"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#aa0b9ba4bfcd10dc3dfaf919cbb610339">storeInFlash</a> (size16_t &amp;index_in_ram)</td></tr>
<tr class="memdesc:aa0b9ba4bfcd10dc3dfaf919cbb610339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes state variable in ram to flash.  <a href="classState.html#aa0b9ba4bfcd10dc3dfaf919cbb610339">More...</a><br /></td></tr>
<tr class="separator:aa0b9ba4bfcd10dc3dfaf919cbb610339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31abb8b0ed41b1e66f36103fbddac2db"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a31abb8b0ed41b1e66f36103fbddac2db">removeFromFlash</a> (const CS_TYPE &amp;type, const cs_state_id_t id)</td></tr>
<tr class="memdesc:a31abb8b0ed41b1e66f36103fbddac2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove given id of given type from flash.  <a href="classState.html#a31abb8b0ed41b1e66f36103fbddac2db">More...</a><br /></td></tr>
<tr class="separator:a31abb8b0ed41b1e66f36103fbddac2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b69f3230f7c1997f7a256ab9b7f5938"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classState.html#a6b69f3230f7c1997f7a256ab9b7f5938">addToQueue</a> (StateQueueOp operation, const CS_TYPE &amp;type, cs_state_id_t id, uint32_t delayMs, const StateQueueMode mode)</td></tr>
<tr class="memdesc:a6b69f3230f7c1997f7a256ab9b7f5938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to queue.  <a href="classState.html#a6b69f3230f7c1997f7a256ab9b7f5938">More...</a><br /></td></tr>
<tr class="separator:a6b69f3230f7c1997f7a256ab9b7f5938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe2a0023b8e2f4f7f80a440c0cc51e1"><td class="memItemLeft" align="right" valign="top"><a id="aefe2a0023b8e2f4f7f80a440c0cc51e1" name="aefe2a0023b8e2f4f7f80a440c0cc51e1"></a>
cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><b>allocate</b> (<a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="separator:aefe2a0023b8e2f4f7f80a440c0cc51e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8db51828e0053ee3d80e28e45d2576"><td class="memItemLeft" align="right" valign="top"><a id="abd8db51828e0053ee3d80e28e45d2576" name="abd8db51828e0053ee3d80e28e45d2576"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delayedStoreTick</b> ()</td></tr>
<tr class="separator:abd8db51828e0053ee3d80e28e45d2576"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad5bdf8d949dd7daa6fd6e9404c9369a8"><td class="memItemLeft" align="right" valign="top"><a id="ad5bdf8d949dd7daa6fd6e9404c9369a8" name="ad5bdf8d949dd7daa6fd6e9404c9369a8"></a>
<a class="el" href="classStorage.html">Storage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_storage</b></td></tr>
<tr class="separator:ad5bdf8d949dd7daa6fd6e9404c9369a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dfa6cb4c5c30e3d3e17a6ccd078849"><td class="memItemLeft" align="right" valign="top"><a id="ac2dfa6cb4c5c30e3d3e17a6ccd078849" name="ac2dfa6cb4c5c30e3d3e17a6ccd078849"></a>
<a class="el" href="structboards__config__t.html">boards_config_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_boardsConfig</b></td></tr>
<tr class="separator:ac2dfa6cb4c5c30e3d3e17a6ccd078849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3db77197d3244fbc3deefdac38ac2d"><td class="memItemLeft" align="right" valign="top"><a id="acd3db77197d3244fbc3deefdac38ac2d" name="acd3db77197d3244fbc3deefdac38ac2d"></a>
std::vector&lt; <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_ram_data_register</b></td></tr>
<tr class="memdesc:acd3db77197d3244fbc3deefdac38ac2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores state data structs with pointers to state data. <br /></td></tr>
<tr class="separator:acd3db77197d3244fbc3deefdac38ac2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1581cd425e1be9b0480579a05e9b63"><td class="memItemLeft" align="right" valign="top"><a id="a4e1581cd425e1be9b0480579a05e9b63" name="a4e1581cd425e1be9b0480579a05e9b63"></a>
std::vector&lt; <a class="el" href="structcs__id__list__t.html">cs_id_list_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_idsCache</b></td></tr>
<tr class="memdesc:a4e1581cd425e1be9b0480579a05e9b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores list of existing ids for certain types. <br /></td></tr>
<tr class="separator:a4e1581cd425e1be9b0480579a05e9b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb96b8b8c16890d48aef2a69baea700"><td class="memItemLeft" align="right" valign="top"><a id="afbb96b8b8c16890d48aef2a69baea700" name="afbb96b8b8c16890d48aef2a69baea700"></a>
std::vector&lt; <a class="el" href="structcs__state__store__queue__t.html">cs_state_store_queue_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_store_queue</b></td></tr>
<tr class="memdesc:afbb96b8b8c16890d48aef2a69baea700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the queue of flash operations. <br /></td></tr>
<tr class="separator:afbb96b8b8c16890d48aef2a69baea700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b98363e46586ae96d74e8215625524e"><td class="memItemLeft" align="right" valign="top"><a id="a5b98363e46586ae96d74e8215625524e" name="a5b98363e46586ae96d74e8215625524e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_startedWritingToFlash</b> = false</td></tr>
<tr class="separator:a5b98363e46586ae96d74e8215625524e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d227f295a560980c01cf0723f45da2"><td class="memItemLeft" align="right" valign="top"><a id="ae0d227f295a560980c01cf0723f45da2" name="ae0d227f295a560980c01cf0723f45da2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_performingFactoryReset</b> = false</td></tr>
<tr class="separator:ae0d227f295a560980c01cf0723f45da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Stores state values in RAM and/or FLASH. </p>
<p >Each state type always has a FIRMWARE_DEFAULT value. Values that are set, always take precedence over the FIRMWARE_DEFAULT.</p>
<p >Values like chip temperature, that don't have to be stored over reboots should be stored in and read from RAM.</p>
<p >Values like CONFIG_BOOT_DELAY should be known over reboots of the device. Moreover, they should also persist over firmware updates. These values are stored in FLASH. If the values are not changed, they should NOT be stored to FLASH. They can then immediately be read from the FIRMWARE_DEFAULT. If these values are stored in FLASH, they always take precedence over FIRMWARE_DEFAULT values. Values that are stored in FLASH will be cached in RAM, to prevent having to read from FLASH every time. This complete persistence strategy is called STRATEGY1.</p>
<p >If a new firmware has a new FIRMWARE_DEFAULT that should be enforced, we need to explicitly remove the value from FLASH before updating the firmware. For example, a new CONFIG_BOOT_DELAY may have to be enforced, or else it might go into an infinite reboot loop.</p>
<p >For each state type it is defined whether it should be stored in RAM or FLASH.</p>
<p >All values that are stored to flash should also be stored in RAM. This is required, because storing to flash is asynchronous, the value must remain in RAM at least until the write is done.</p>
<p >Storing to flash can also fail, in which case it can be retried later. The state type will be put in a queue and retried after about STATE_RETRY_STORE_DELAY_MS ms.</p>
<p >Get procedure:</p><ol type="1">
<li>Read RAM<ul>
<li>if present, return RAM value.</li>
</ul>
</li>
<li>Get location (FLASH or RAM) 3a. If RAM<ul>
<li>get default value.</li>
<li>store default value in RAM. 3b. If FLASH</li>
<li>read FLASH</li>
<li>if present, copy FLASH value to RAM.</li>
<li>if not present, get default value, store default value in RAM.</li>
</ul>
</li>
<li>Copy RAM value to return value.</li>
</ol>
<p >Set procedure:</p><ol type="1">
<li>Copy value to RAM.</li>
<li>Get location (FLASH or RAM)<ul>
<li>If RAM, return.</li>
</ul>
</li>
<li>Write to storage.<ul>
<li>If success, return.</li>
<li>If busy, add state type to queue, return. </li>
</ul>
</li>
</ol>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6b69f3230f7c1997f7a256ab9b7f5938" name="a6b69f3230f7c1997f7a256ab9b7f5938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b69f3230f7c1997f7a256ab9b7f5938">&#9670;&nbsp;</a></span>addToQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::addToQueue </td>
          <td>(</td>
          <td class="paramtype">StateQueueOp&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CS_TYPE &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs_state_id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delayMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StateQueueMode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an operation to queue. </p>
<p >Entries with the same type and operation will be overwritten. Write and remove of the same type will also overwrite each other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">operation</td><td>Type of operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileId</td><td>Flash file ID of the entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delayMs</td><td>Delay in ms. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="a42147d96fff13879450686937c7a1a93" name="a42147d96fff13879450686937c7a1a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42147d96fff13879450686937c7a1a93">&#9670;&nbsp;</a></span>addToRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp; State::addToRam </td>
          <td>(</td>
          <td class="paramtype">const CS_TYPE &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs_state_id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new state_data struct to ram. </p>
<p >Allocates the struct and the data pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td><a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> variable size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Struct with allocated data pointer. </dd></dl>

</div>
</div>
<a id="a4f122ed63d6c04b8aba8e27e0f5249fe" name="a4f122ed63d6c04b8aba8e27e0f5249fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f122ed63d6c04b8aba8e27e0f5249fe">&#9670;&nbsp;</a></span>cleanUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::cleanUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up persistent storage. </p>
<p >Permanently deletes removed state variables, and defragments the persistent storage.</p>
<dl class="section return"><dt>Returns</dt><dd>Success when cleaning up will be started. </dd></dl>

</div>
</div>
<a id="ac3b62ec4b0cff5f5e7a4446a5c19877b" name="ac3b62ec4b0cff5f5e7a4446a5c19877b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b62ec4b0cff5f5e7a4446a5c19877b">&#9670;&nbsp;</a></span>compareWithRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::compareWithRam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>cmp_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a particular value with the value currently in ram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data with type, id, value, and size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cmp_result</td><td>Value that indicates comparison (equality indicated by 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code (e.g. ERR_SUCCESS, ERR_NOT_FOUND, etc.) </dd></dl>

</div>
</div>
<a id="a32a47427f426acbdc17d35eefe111890" name="a32a47427f426acbdc17d35eefe111890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a47427f426acbdc17d35eefe111890">&#9670;&nbsp;</a></span>findInRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::findInRam </td>
          <td>(</td>
          <td class="paramtype">const CS_TYPE &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs_state_id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size16_t &amp;&#160;</td>
          <td class="paramname"><em>index_in_ram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find given type in ram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Type</td><td>to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Id</td><td>to search for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Index</td><td>in ram register where the type was found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_SUCCESS when type was found. </dd>
<dd>
ERR_NOT_FOUND when type was not found. </dd></dl>

</div>
</div>
<a id="a63baa15ae12ca1d3b009bf908c65ad73" name="a63baa15ae12ca1d3b009bf908c65ad73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63baa15ae12ca1d3b009bf908c65ad73">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::get </td>
          <td>(</td>
          <td class="paramtype">const CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for <a class="el" href="classState.html#a5a02973119b3d6fd68ed47fbcac198e6" title="Get copy of a state value.">get()</a> with id 0. </p>
<p >Avoids having to create a temp every time you want to get a state variable. </p>

</div>
</div>
<a id="a5a02973119b3d6fd68ed47fbcac198e6" name="a5a02973119b3d6fd68ed47fbcac198e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a02973119b3d6fd68ed47fbcac198e6">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PersistenceMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>PersistenceMode::STRATEGY1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get copy of a state value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data struct with state type, id, data, and size. See <a class="el" href="structcs__state__data__t.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: Oct 9,...">cs_state_data_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates whether to get data from RAM, FLASH, FIRMWARE_DEFAULT, or a combination of this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="ae36a79c4643010cc2adf73a75b8447fb" name="ae36a79c4643010cc2adf73a75b8447fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36a79c4643010cc2adf73a75b8447fb">&#9670;&nbsp;</a></span>getIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::getIds </td>
          <td>(</td>
          <td class="paramtype">CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cs_state_id_t &gt; *&amp;&#160;</td>
          <td class="paramname"><em>ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of IDs for given type. </p>
<p >Example usage: std::vector&lt;cs_state_id_t&gt;* ids = nullptr; retCode = <a class="el" href="classState.html#ad18d563a732ed9d6659d6b38492f89dc" title="Get a reference to the State object.">State::getInstance()</a>.getIds(CS_TYPE::STATE_EXAMPLE, ids); if (retCode == ERR_SUCCESS) { for (auto id: *ids) {</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Pointer to list of ids. This is not a copy, so make sure not to modify this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="a1759335a4b5529aff8a9221db3d35559" name="a1759335a4b5529aff8a9221db3d35559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1759335a4b5529aff8a9221db3d35559">&#9670;&nbsp;</a></span>getViaPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::getViaPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PersistenceMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>PersistenceMode::STRATEGY1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to state value. </p>
<p >TODO: implement You can use this to avoid copying large state values of fixed length. However, you have to make sure to call <a class="el" href="classState.html#aa80421b79db2b144889db602e12a39ef" title="Update state value.">setViaPointer()</a> immediately after any change made in the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data struct with state type and size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7669e3e5afe2e3280630d785afc9ef34" name="a7669e3e5afe2e3280630d785afc9ef34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7669e3e5afe2e3280630d785afc9ef34">&#9670;&nbsp;</a></span>handleEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void State::handleEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classevent__t.html">event_t</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle (crownstone) events. </p>

<p>Implements <a class="el" href="classEventListener.html#ab746290fb9240d83d231cd390c3cafad">EventListener</a>.</p>

</div>
</div>
<a id="ad37d1373fa95b45718ff471799dfc067" name="ad37d1373fa95b45718ff471799dfc067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37d1373fa95b45718ff471799dfc067">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void State::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboards__config__t.html">boards_config_t</a> *&#160;</td>
          <td class="paramname"><em>boardsConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> object with the board configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">boardsConfig</td><td>Board configuration (pin layout, etc.). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af808c9d5d864e8a9459bc1617f6cdb1a" name="af808c9d5d864e8a9459bc1617f6cdb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af808c9d5d864e8a9459bc1617f6cdb1a">&#9670;&nbsp;</a></span>isTrue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool State::isTrue </td>
          <td>(</td>
          <td class="paramtype">CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PersistenceMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>PersistenceMode::STRATEGY1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shorthand for <a class="el" href="classState.html#a5a02973119b3d6fd68ed47fbcac198e6" title="Get copy of a state value.">get()</a> for boolean data types, and id 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates whether to get data from RAM, FLASH, FIRMWARE_DEFAULT, or a combination of this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when state type is true. </dd></dl>

</div>
</div>
<a id="a0d45df4e62a87a10b5cc854b9bad1236" name="a0d45df4e62a87a10b5cc854b9bad1236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d45df4e62a87a10b5cc854b9bad1236">&#9670;&nbsp;</a></span>loadFromRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::loadFromRam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies from ram to target buffer. </p>
<p >Does not check if target buffer has a large enough size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data.type</td><td>Type of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data.id</td><td>Identifier of the data (to get a particular instance of a type). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data.size</td><td>The size of the data retrieved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data.value</td><td>The data itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value (i.e. ERR_SUCCESS or other). </dd></dl>

</div>
</div>
<a id="ad477ee685332e4424e80848abdae1412" name="ad477ee685332e4424e80848abdae1412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad477ee685332e4424e80848abdae1412">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::remove </td>
          <td>(</td>
          <td class="paramtype">const CS_TYPE &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs_state_id_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PersistenceMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>PersistenceMode::STRATEGY1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a state variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The state type to be removed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates whether to remove data from RAM, FLASH, or a combination of this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="a31abb8b0ed41b1e66f36103fbddac2db" name="a31abb8b0ed41b1e66f36103fbddac2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31abb8b0ed41b1e66f36103fbddac2db">&#9670;&nbsp;</a></span>removeFromFlash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::removeFromFlash </td>
          <td>(</td>
          <td class="paramtype">const CS_TYPE &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cs_state_id_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove given id of given type from flash. </p>
<p >Can return ERR_BUSY, in which case you have to retry again later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td><a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> value id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="a92388d397775a8af4318403e33972fad" name="a92388d397775a8af4318403e33972fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92388d397775a8af4318403e33972fad">&#9670;&nbsp;</a></span>removeFromRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::removeFromRam </td>
          <td>(</td>
          <td class="paramtype">const CS_TYPE &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs_state_id_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removed a state variable from ram. </p>
<p >Frees the data pointer and struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="classState.html" title="Stores state values in RAM and/or FLASH.">State</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="a8451f4870511d24e4fe931c1cf4d6246" name="a8451f4870511d24e4fe931c1cf4d6246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8451f4870511d24e4fe931c1cf4d6246">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PersistenceMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>PersistenceMode::STRATEGY1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set state to new value, via copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data struct with state type, optional id, data, and size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates whether to set data in RAM, FLASH, or a combination of this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ERR_SUCCESS The data has been set, and (depending on mode) will be written to flash. There will be an event EVT_STORAGE_WRITE_DONE once it's actually written to flash. </dd>
<dd>
ERR_SUCCESS_NO_CHANGE The data did not change, and thus will NOT be written to flash. There will be NO event EVT_STORAGE_WRITE_DONE. Warning: when <a class="el" href="classState.html#a42cff7fd1b35b70a093ccfa4f5829769" title="Set the state to a new value, but delay the write to flash.">setDelayed()</a> was used before <a class="el" href="classState.html#a8451f4870511d24e4fe931c1cf4d6246" title="Set state to new value, via copy.">set()</a>, it can happen that this code is returned, while the data is not written to flash yet. </dd>
<dd>
Other codes for errors. </dd></dl>

</div>
</div>
<a id="a3f411b0baa1244bd3202502dc9a44bd7" name="a3f411b0baa1244bd3202502dc9a44bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f411b0baa1244bd3202502dc9a44bd7">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::set </td>
          <td>(</td>
          <td class="paramtype">const CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for <a class="el" href="classState.html#a8451f4870511d24e4fe931c1cf4d6246" title="Set state to new value, via copy.">set()</a>. </p>
<p >Avoids having to create a temp every time you want to set a state variable. </p>

</div>
</div>
<a id="a42cff7fd1b35b70a093ccfa4f5829769" name="a42cff7fd1b35b70a093ccfa4f5829769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cff7fd1b35b70a093ccfa4f5829769">&#9670;&nbsp;</a></span>setDelayed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::setDelayed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state to a new value, but delay the write to flash. </p>
<p >Assumes persistence mode STRATEGY1. Use this when you know a lot of sets of the same type may be done in a short time period. Each time this function is called, the timeout is reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data struct with state type, data, and size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>How long the delay should be, in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="ad37d56e82b944fa5cc8bce060ebd2ff6" name="ad37d56e82b944fa5cc8bce060ebd2ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37d56e82b944fa5cc8bce060ebd2ff6">&#9670;&nbsp;</a></span>setThrottled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::setThrottled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write variable to flash in a throttled mode. </p>
<p >This function setThrottled will immediately write a value to flash, except when this has happened in the last period (indicated by a parameter). If this function is called during this period, the value will be updated in ram. Only after this period this value will then be written to flash. Also after this time, this will lead to a period in which throttling happens. For example, when the period parameter is set to 60000, all calls to setThrottled will result to calls to flash at a maximum rate of once per minute (for given data type).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to store. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>Period in seconds that throttling will be in effect. Must be smaller than CS_STATE_QUEUE_DELAY_SECONDS_MAX. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code (e.g. ERR_SUCCES, ERR_WRONG_PARAMETER). </dd></dl>

</div>
</div>
<a id="aa80421b79db2b144889db602e12a39ef" name="aa80421b79db2b144889db602e12a39ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80421b79db2b144889db602e12a39ef">&#9670;&nbsp;</a></span>setViaPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::setViaPointer </td>
          <td>(</td>
          <td class="paramtype">CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update state value. </p>
<p >TODO: implement Call this function after data has been changed via pointer. This makes sure the update will be propagated correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The state type that has been changed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31f85d6f2813360b7c4e65078d324a9e" name="a31f85d6f2813360b7c4e65078d324a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f85d6f2813360b7c4e65078d324a9e">&#9670;&nbsp;</a></span>startWritesToFlash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void State::startWritesToFlash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After calling this, state is allowed to write to flash. </p>
<p >Should be called once all reads are finished.</p>
<p >This is a quickfix to prevent failing flash reads during garbage collection. To properly fix this, read should be blocking. This can be done by handling FDS events in the interrupt, instead of via the app_scheduler. In those events, the busy state can be cleared, while cs events can be dispatched via the app_scheduler. Then, the read function can just wait with nrf_delay() until no longer busy. </p>

</div>
</div>
<a id="aa0b9ba4bfcd10dc3dfaf919cbb610339" name="aa0b9ba4bfcd10dc3dfaf919cbb610339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b9ba4bfcd10dc3dfaf919cbb610339">&#9670;&nbsp;</a></span>storeInFlash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::storeInFlash </td>
          <td>(</td>
          <td class="paramtype">size16_t &amp;&#160;</td>
          <td class="paramname"><em>index_in_ram</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes state variable in ram to flash. </p>
<p >Can return ERR_BUSY, in which case you have to retry again later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index in ram with the data to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="a0f8f20fff6d3e4206999d9731f6fa607" name="a0f8f20fff6d3e4206999d9731f6fa607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8f20fff6d3e4206999d9731f6fa607">&#9670;&nbsp;</a></span>storeInRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::storeInRam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size16_t &amp;&#160;</td>
          <td class="paramname"><em>index_in_ram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores state variable in ram. </p>
<p >Allocates memory when not in ram yet, or when size changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index_in_ram</td><td>Index where the data is stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="a6d963b9f6ade3b8662e1ff0062e27708" name="a6d963b9f6ade3b8662e1ff0062e27708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d963b9f6ade3b8662e1ff0062e27708">&#9670;&nbsp;</a></span>verifySizeForGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::verifySizeForGet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify size of user data for getting a state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data struct with state type, target, and size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<a id="a46d2af69aaa0380f678f138be0618e02" name="a46d2af69aaa0380f678f138be0618e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d2af69aaa0380f678f138be0618e02">&#9670;&nbsp;</a></span>verifySizeForSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t State::verifySizeForSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify size of user data for setting a state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data struct with state type, data, and size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return code. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/include/storage/<a class="el" href="cs__State_8h_source.html">cs_State.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classState.html">State</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
