<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bluenet: Build system</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
	DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bluenet
   &#160;<span id="projectnumber">5.4.0</span>
   </div>
   <div id="projectbrief">Bluenet, the firmware for the Crownstone power outlet</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_development_environment_BUILD_SYSTEM.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Build system </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >We are using the <code>CMake</code> build system. There are some old scripts in <code>source/scripts</code>. They are slowly phased out to make place for <code>CMake</code> equivalents.</p>
<p >The purpose of <a href="https://cmake.org/">CMake</a>:</p>
<ul>
<li>Compilation that is independent of platform and compiler.</li>
</ul>
<p >In practice we do not need so much to be independent of the compiler, but the independence of the platform potentially means we can support development on both Linux, Mac, as well as Windows. Moreover, it has the following benefits, especially if also used to download prerequisite tools.</p>
<ul>
<li>More reliable code completion in code editors</li>
<li>Same versions of build tools for every developer</li>
<li>The version of the tools that have been used are checked into the code repository can can be used for reproduction.</li>
<li>Continuous integration by a few simple commands</li>
<li>Construction of a docker image by a few simple commands</li>
</ul>
<h1><a class="anchor" id="autotoc_md256"></a>
Dependencies</h1>
<p >There are couple of tools that are expected to by present on your system. If you are on Ubuntu download scripts for such tools can be found at <code>scripts/download</code>.</p>
<p >Absolutely required is the cross-compiler. </p><pre class="fragment">./download-ubuntu-gcc-arm-none-eabi.sh ../..
</pre><p> This places the cross-compiler in the <code>tools</code> directory that can be found by <code>cmake</code>.</p>
<p >To download <code>JLinkExe</code> on Ubuntu (required to flash development boards or Crownstones over a JLink device): </p><pre class="fragment">cd scripts/download
./download-ubuntu-jlink.sh ../..
</pre><p> Similarly download <code>nrfjprog</code> (also required for flashing hardware). </p><pre class="fragment">./download-ubuntu-nrfjprog.sh ../..
</pre> <h1><a class="anchor" id="autotoc_md257"></a>
Downloads</h1>
<p >When running <code>cmake</code> and <code>make</code> there are a couple of sources that are obtained automatically:</p>
<ul>
<li>Nordic SDK</li>
<li>Nordic <a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a></li>
</ul>
<p >The Softdevice is part of the Nordic SDK and does not need to be downloaded separately.</p>
<h1><a class="anchor" id="autotoc_md258"></a>
Checks</h1>
<p >The continuous integration system (Github Actions) does not need JLink nor nrfjprog. To remove the checks against their existence run cmake with the options: </p><pre class="fragment">cmake .. -DREQUIRE_JLINK=OFF -DREQUIRE_NRFJPROG=OFF
</pre><p> We currently do not check for the versions of those tools.</p>
<h1><a class="anchor" id="autotoc_md259"></a>
Downloads of optional tools</h1>
<p >There are also a bundle of more or less optional tools.</p>
<ul>
<li>Nordic nrfconnect software</li>
<li>The bluenet binary logger</li>
<li>The <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> Python libs</li>
<li>The <code>csutil</code> tool for microapps</li>
</ul>
<p >One of the convenient optional tools from Nordic is the Nordic nrf connect tool. It reads out how the memory layout is implemented and displays this in a very nice way (see Figure).</p>
<p ><img src="../images/pc_nordic_tools.png" alt="Nordic Tools" class="inline"/></p>
<p >You can download <code>nrfconnect</code> by </p><pre class="fragment">./download-ubuntu-nrfconnect-core.sh ../..
./download-ubuntu-nrfconnect-programmer.sh ../..
</pre><p> This particular tool requires <code>npm</code>. Install it through something like <code>sudo apt install npm</code>. Subsequently, it downloads a lot of stuff, amongst which also <code>nrfjprog</code> it it cannot find it. Make sure it does not lead to version conflicts.</p>
<p >You can run these tools by: </p><pre class="fragment">make nrfconnect_core_setup
make nrfconnect_core
</pre><p> These run in separate shells. The <code>_setup</code> you at least have to run once. After that it can do continuous rebuilds. You can select the tool to use from the list of apps. By default there are now quite a few apps there. The programmer can also be downloaded separately by setting the <code>-DDOWNLOAD_NRFCONNECT_PROGRAMMER=ON</code> flag at <code>CMake</code>.</p>
<p >There might be more download options in the future. Check the <code>cmake</code> options by running in the build directory (after <code>sudo apt-get install -y cmake-gui</code>): </p><pre class="fragment">cmake-gui .
</pre><p> Then you will see their (cached) values. Some examples of other options are <code>-DDOWNLOAD_BLUENET_LIB_LOGS=ON</code> which will download the binary logging tool for you and <code>-DDOWNLOAD_CSUTIL=ON</code> which will download a utility for uploading microapps. Just the targets are also listed through: </p><pre class="fragment">make help
</pre> <h1><a class="anchor" id="autotoc_md260"></a>
Build offline</h1>
<p >If you have worked on bluenet before (and downloaded dependencies) and subsequently you want to build the project, the <code>cmake</code> build system requires an internet connection to check if the downloaded code such as the Nordic SDK etc are still up to date. You can disable this by the following option. </p><pre class="fragment">cmake .. -DBUILD_OFFLINE=ON
</pre><p> Make sure you set this back to pick up the latest changes in the project's dependencies.</p>
<h1><a class="anchor" id="autotoc_md261"></a>
Python virtual environment</h1>
<p >Although it is possible to use bluenet without a Python virtual environment, it is discouraged.</p>
<h2><a class="anchor" id="autotoc_md262"></a>
Patches</h2>
<p >We used to have patches that are run against a downloaded code base, e.g. the mesh sdk. Now we run a copy of the code on github with all proper patches already applied. There's no need to perform patches for that reason.</p>
<h1><a class="anchor" id="autotoc_md263"></a>
Configuration</h1>
<p >Loading a particular board configuration, say <code>config/default/CMakeBuild.config</code>, is done in a cross-platform manner, namely by reading out the file and parsing it in CMake itself.</p>
<p >The file that does this can be found in <code>source/conf/cmake/modules/load_configuration.cmake</code>. It loads the file that it's given as its first parameter and adds to the list that it's given as its second parameter. This list is just a list in the form of "-DKEY0:STRING=VALUE0 -DKEY1:STRING=VALUE1". This can be forwarded to other CMake projects, but does not yet give this particular build access to those keys and values. Henceforth, a side-effect of this function is that it also sets those keys with their values in the <code>PARENT_SCOPE</code>. That means that values like <code>SERIAL_NUM</code>, <code>GDB_PORT</code> etc. become available to the parent CMake build.</p>
<p >There is also a <code>config/$target/CMakeBuild.overwrite.config</code> file that will be sourced after <code>config/$target/CMakeBuild.config</code> and that you can use to write specifics to the particular system you are working on.</p>
<p >There is also a <code>config/$target/CMakeBuild.runtime.config</code> file that will only be used at <b>runtime</b>. This means that if you set <code>SERIAL_NUM</code> or <code>GDB_PORT</code> in this file, it will immediately pick up these values without you having to run <code>cmake</code>. For example <code>make reset</code> will immediately reset the right device (without a configuration or compilation step).</p>
<h1><a class="anchor" id="autotoc_md264"></a>
Dependency on configuration</h1>
<p >The dependency on the configuration file is made possible to adding it explicitly as a dependency on the source files. Only adding it as dependency on the target will cause the linker to run again after changing configuration values, but it does not run the compiler because it does not know that object files could potentially change.</p>
<p >A different solution strategy would be to have a <code>configure_file</code> command that generates a header file from our configuration file, so that automatically only the source files that link into this changed header file will need to be rebuild. However, in our build we allow for multiple targets. This would either:</p>
<ol type="1">
<li>Have a header file in the code repository that changes all the time. By switching from board to board the entire compilation tree has to be rebuild.</li>
<li>Have a header file in the separate <code>config/boardX</code> directory. This however complicates the building process. The source files have to link suddenly to some header file on a dynamic location. This is likely to confuse any IDE.</li>
</ol>
<p >The disadvantage is that we have a very large set of compiler flags that we pass to the compiler. If not running make as <code>VERBOSE=1 make</code>, those will not be visible to the user.</p>
<p >To actually add this dependency we need <code>set_source_files_properties</code> with <code>OBJECT_DEPENDS</code>: </p><pre class="fragment">set_source_files_properties(${FOLDER_SOURCE}
    PROPERTIES OBJECT_DEPENDS ${WORKSPACE_DIR}/config/${BOARD_TARGET}/CMakeBuild.config
)
</pre><p> Also add the dependency to the target binary.</p>
<p >We do one thing more, we also make sure CMake itself is triggered on a change. </p><pre class="fragment">set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS ${WORKSPACE_DIR}/config/${BOARD_TARGET}/CMakeBuild.config)
</pre><p> Beautiful. :-)</p>
<h1><a class="anchor" id="autotoc_md265"></a>
Board versions</h1>
<p >To actually extract the proper board versions, we do some string manipulation using <code>CMake</code> itself. The file can be found in <code>source/conf/cmake/modules/load_hardware_version_mapping.cmake</code>. This defines two functions. One returns the board version given a board name. The other maps the other way around.</p>
<p >This function requires the header file <code><a class="el" href="cs__Boards_8h_source.html">source/include/cfg/cs_Boards.h</a></code> as first argument. It parses all the macro definitions and will use those as mappings. </p><pre class="fragment">#define ACR01B10D    1008
</pre><p> The regular expression might actually fail if you create fancy commands with <code>#define</code> statements in there. The mapping is used to write the board version to UICR. </p><pre class="fragment">make write_hw_version
</pre><p> Reading it, uses the inverse function.</p>
<h1><a class="anchor" id="autotoc_md266"></a>
Target</h1>
<p >The target is something like <code>crownstone</code>. However, there are other files that are generated as well. There is a binary file, a hex file, and an elf file. The file without extension is the same as the .elf file. Then there are two more files generated: </p><pre class="fragment">${CMAKE_OBJCOPY} -O binary ${PROJECT_NAME} ${PROJECT_NAME}.bin
${CMAKE_OBJCOPY} -O ihex ${PROJECT_NAME} ${PROJECT_NAME}.hex
</pre><p> The executable is made dependent on those files, so they will always be generated. The .hex file is the one accepted by the <code>nrfjprog</code> tool. The <code>.bin</code> file might be used by less sophisticated tools. The .elf file is required for debugging (it contains the symbols).</p>
<h1><a class="anchor" id="autotoc_md267"></a>
Hierarchy</h1>
<p >The parent build uses <code>ExternalProject</code> to both download the external dependencies and compile the <code>bluenet</code> source directory (which in its turn also compiles the bootloader). The latter is not done through <code>ExternalProject</code>, but directly by <code>add_subdirectory</code>. This means that all cross-compilation information is directly available to it. It also means that the bootloader is build together with the firmware.</p>
<h1><a class="anchor" id="autotoc_md268"></a>
Similarly named header files</h1>
<p >Both the firmware as well as the bootloader use an <code>sdk_config.h</code> file. They are located in different directories. Due to the fact that the bootloader is linked through <code>add_subdirectory</code> it inherits all the same include directories. It is important to not include the directory in which aforementioned file is stored.</p>
<p >Hence, we add this include directory only to firmware target (not the bootloader): </p><pre class="fragment">set(INCLUDE_DIR "include" "include/ble" "include/third") # not here
...
target_include_directories(${PROJECT_NAME} PRIVATE "include/third/nrf") # here
</pre><p> Note, it is harder to figure out that the wrong file is used when the <code>ifndef</code> macro only checks on a mangled filename: </p><pre class="fragment">#ifndef SDK_CONFIG_H
#define SDK_CONFIG_H
...
#endif
</pre><p> You might be surprised by which file gets included. There's a perfectly modern alternative </p><pre class="fragment">#pragma once
</pre><p> Use that. Yes, it is non-standard, but <a href="https://stackoverflow.com/questions/787533/is-pragma-once-a-safe-include-guard">convince me</a>.</p>
<h1><a class="anchor" id="autotoc_md269"></a>
External tools</h1>
<p >The proper way to use an external tool such as nrfjprog where we have to process the output is by using a dedicated CMake script. An example is given in <code>nrfjprog.cmake</code>.</p>
<p >This changes a call like the following </p><pre class="fragment">COMMAND nrfjprog -f nrf52 --memrd 0x000300C 
</pre><p> To something like </p><pre class="fragment">COMMAND ${CMAKE_COMMAND} -DINSTRUCTION:STRING=READ -DADDRESS:STRING=0x000300C -P ${DEFAULT_MODULES_PATH/nrfjprog.cmake
</pre><p> We want to do this because we want to parse the output of such a command. By incorporating it into a CMake script we can use <code>execute_process</code>. This can run a utility like <code>nrfjprog</code> and can capture stdout, stderr, and the error status. Subsequently, we can use CMake itself to process the results with the appropriate regular expressions.</p>
<p >For now, this has been implemented for <code>make read_softdevice_version</code>. Other calls where we process the output of a command line tool have to be implemented still.</p>
<p >Note that the <code>-P</code> switch has to be the last one. In the code a set of defines are put together in the variable <code>${DEFAULT_NRFUTIL_READ_DPARAM}</code>.</p>
<h1><a class="anchor" id="autotoc_md270"></a>
TODO</h1>
<p >The following things can be done:</p>
<ul>
<li>The external tools that are downloaded right now are the ones for a Linux OS. The .zip, .gz, and .deb files have to be adjusted for another OS. Their installation commands needs to be adjusted as well.</li>
<li>The patches in <code>PATCH_COMMAND</code> after a download are OS specific.</li>
<li>Implement cross-platform file for external commands other than <code>make read_softdevice_version</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md271"></a>
Tips &amp; Tricks</h1>
<p >The difference between <code>SET</code> and <code>OPTION</code> is minimal. The latter only has <code>ON</code> and <code>OFF</code> as values. That's all.</p>
<h2><a class="anchor" id="autotoc_md272"></a>
Cross-platform</h2>
<p >If an external <code>COMMAND</code> is executed, always use the CMake built-in option (<code>CMAKE_COMMAND</code>) if it's available. </p><pre class="fragment">COMMAND ${CMAKE_COMMAND} -E echo "This one"
COMMAND echo "Not this one"
</pre><p> The first command is cross-platform, the second is not.</p>
<h2><a class="anchor" id="autotoc_md273"></a>
Spaces</h2>
<p >In an external <code>COMMAND</code> CMake is often placing a backslash in from of a space. This is not always solved by adding VERBATIM. There is however another "trick".</p>
<p >This does NOT work: </p><pre class="fragment">set(SERIAL_SWITCH_AND_NUM "--snr 123456")
...
COMMAND nrfjprog -f nrf52 --memrd 0x000300C ${SERIAL_SWITCH_AND_NUM}
</pre><p> The following DOES work </p><pre class="fragment">set(SERIAL_SWITCH "--snr")
set(SERIAL_NUM "123456")
...
COMMAND nrfjprog -f nrf52 --memrd 0x000300C ${SERIAL_SWITCH} ${SERIAL_NUM}
</pre> <h2><a class="anchor" id="autotoc_md274"></a>
Clean</h2>
<p >You might think dependencies are managed by <code>make</code>, but this is not true. The dependencies are managed by <code>cmake</code>. See for example <a href="https://stackoverflow.com/questions/56155681/cmake-make-object-dependency-issue-not-rebuilding-when-header-changes">this question on SO</a>. A <code>depend.make</code> file is generated by <code>cmake</code> and especially if particular header files are not used anymore after a refactoring it might be the case that this file is not updated. Just running <code>make clean</code> is not sufficient. You can rebuild the dependencies by: </p><pre class="fragment">make depend
</pre><p> For any suggestion to improve the build system, file an issue at the issue tracker on github! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
