/*
 * Author: Crownstone Team
 * Copyright: Crownstone (https://crownstone.rocks)
 * Date: Nov 17, 2020
 * License: LGPLv3+, Apache License 2.0, and/or MIT (triple-licensed)
 */

#pragma once

#include <events/cs_EventListener.h>
#include <localisation/cs_Nearestnearestwitnessreport.h>
#include <localisation/cs_TrackableEvent.h>
#include <protocol/cs_Typedefs.h>
#include <protocol/mesh/cs_MeshModelPackets.h>

/**
 * This class implements the in-mesh computation of which crownstone
 * is nearest to a 'trackable' device.
 *
 * When a trackable device broadcasts an advertisement, and the TrackableParser
 * consequently dispatches a TrackableEvent, it is this class that performs the necessary
 * communication and computation to decide whether or not this crownstone is closest to
 * the trackable device.
 *
 * It is possible to enable this component on a subset of the crownstones in a mesh
 * if necessary (for optimization purposes perhaps). When doing that, the resulting nearest
 * crownstone will be an element of this subset.
 */
class NearestCrownstoneTracker: public EventListener {
public:
	/**
	 * Caches CONFIG_CROWNSTONE_ID, and resets the report maps.
	 */
	void init();

	/**
	 * Handlers for:
	 * EVT_MESH_NEAREST_WITNESS_REPORT
	 * EVT_TRACKABLE
	 */
	void handleEvent(event_t &evt);

private:
	TYPIFY(CONFIG_CROWNSTONE_ID) _myId; // cached for efficiency

	// TODO: expand to a map<TrackableID, NearestWitnessReport>.
	/**
	 * The most recent witness report generated by this crownstone.
	 * (Updated on EVT_TRACKABLE)
	 */
	NearestWitnessReport _personalReport;
	/**
	 * Witness report of the currently closest crownstone.
	 * (Updated on EVT_MESH_NEAREST_WITNESS_REPORT, if it is better than previous etc.)
	 */
	NearestWitnessReport _winningReport;

	/**
	 * Heart of the algorithm. See implementation for exact behaviour.
	 *
	 * Updates personal report, possibly updates winning report
	 * and possibly broadcasts a message to inform other devices
	 * in the mesh of relevant changes.
	 */
	void onReceive(TrackableEvent* trackedEvent);

	/**
	 * Heart of the algorithm. See implementation for exact behaviour.
	 *
	 * Possibly updates winning report and possibly broadcasts
	 * a message to inform other devices in the mesh of relevant changes.
	 * E.g. when the updated winning report now loses from this devices
	 * personal report.
	 */
	void onReceive(NearestWitnessReport& report);

	/**
	 * Creates a NearestWitnessReport for the given TrackableEvent using myId.
	 */
	NearestWitnessReport createReport(TrackableEvent* trackedEvent);

	/**
	 * Expands the mesh representation of type nearest_witness_report_t to
	 * the firmware representation of type NearestWitnessReport.
	 */
	NearestWitnessReport createReport(MeshMsgEvent* trackableAdvertisement);

	/**
	 * Returns a nearest_witness_report_t that can be sent over the mesh.
	 */
	nearest_witness_report_t reduceReport(const NearestWitnessReport& report);

	/**
	 * Only does an asignment to personal_report.
	 */
	void savePersonalReport(NearestWitnessReport report);

	/**
	 * Only does an asignment to winning_report.
	 */
	void saveWinningReport(NearestWitnessReport report);

	/**
	 * Sends a mesh broadcast for the given report.
	 */
	void broadcastReport(NearestWitnessReport report);

	/**
	 * Currently dispatches an event for CMD_SWITCH_[ON,OFF] depending on
	 * whether this crownstone is closest (ON) or not the closest.
	 *
	 * Also outputs the current winner to UART for demo purposes.
	 */
	void onWinnerChanged();

	/**
	 * Returns report.rssi != 0.
	 *
	 * Only used to see if a prior NearestWitnessReport exists.
	 * When adding the multiple TrackableIds feature this method
	 * becomes obsolete. We can then use map::find to check if a winnin/personal
	 * report exists.
	 */
	bool isValid(const NearestWitnessReport& report);

	/**
	 * Assumes my_id is set to the stone id of this crownstone.
	 */
	void resetReports();

	void logReport(const char* text, NearestWitnessReport report);
};

