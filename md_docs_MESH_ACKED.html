<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bluenet: MESH_ACKED</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
	DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bluenet
   &#160;<span id="projectnumber">5.4.0</span>
   </div>
   <div id="projectbrief">Bluenet, the firmware for the Crownstone power outlet</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_MESH_ACKED.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">MESH_ACKED </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >This document shows the code flow for acked mesh messages, based on an example command. A lot of details are left out, so we can focus on how the ack/reply is implemented.</p>
<p >Example case:</p><ul>
<li>The user sends a mesh command via UART to <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 1.</li>
<li>The mesh command orders <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 1 to send an acked, single target, mesh message to <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 2.</li>
<li>The mesh message is a control command to print something ("hi") to UART.</li>
<li>After <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 2 printed the text, it sends a reply to <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 1.</li>
<li><a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 1 then reports the result via UART, with a <code><a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a> result</code> message, and a <code><a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a> ack all</code> message. See the <a href="protocol/UART_PROTOCOL.md#rx-data-types-events-and-replies">UART protocol</a></li>
</ul>
<p >The communication is as follows:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">  participant uart_a as &quot;UART 1&quot;</div>
<div class="line">  participant a as &quot;Crownstone 1&quot;</div>
<div class="line">  participant b as &quot;Crownstone 2&quot;</div>
<div class="line">  participant uart_b as &quot;UART 2&quot;</div>
<div class="line"> </div>
<div class="line">  uart_a -&gt; a : type = CTRL_CMD_MESH_COMMAND&lt;br/&gt;payload =&lt;br/&gt;    targetIds = [2]&lt;br/&gt;    flags = unicast &amp; acked&lt;br/&gt;    type = CTRL_CMD_UART_MSG&lt;br/&gt;    data = &quot;hi&quot;</div>
<div class="line">  a -&gt; b      : opcode = UNICAST_RELIABLE&lt;br/&gt;type = CS_MESH_MODEL_TYPE_CTRL_CMD&lt;br/&gt;payload =&lt;br/&gt;    ctrl_cmd = CTRL_CMD_UART_MSG&lt;br/&gt;    data = &quot;hi&quot;</div>
<div class="line">  b -&gt; uart_b : &quot;hi&quot;</div>
<div class="line">  b -&gt; a      : opcode = UNICAST_REPLY&lt;br/&gt;msg =&lt;br/&gt;    ctrl_cmd = CTRL_CMD_UART_MSG&lt;br/&gt;    result_code = SUCCESS</div>
<div class="line">  a -&gt; uart_a : mesh_result =&lt;br/&gt;    stone_id = 2&lt;br/&gt;    ctrl_cmd = CTRL_CMD_UART_MSG&lt;br/&gt;    result_code = SUCCESS</div>
<div class="line">  a -&gt; uart_a : mesh_ack_all =&lt;br/&gt;    ctrl_cmd = CTRL_CMD_UART_MSG&lt;br/&gt;    result_code = SUCCESS</div>
</div><!-- fragment --><p >Now let's dive into the implementation. Each line shows the next function that is called, for simplification, we don't show the nesting of calls. Sometimes the most relevant function arguments are shown. When variables are set in the function, this is shown with <code>:=</code>.</p>
<p >We start at the UART command handler of <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 1: </p><div class="fragment"><div class="line">UartCommandHandler::handleCommandControl()</div>
<div class="line"> </div>
<div class="line">CommandHandler::handleEvent(event.type = CMD_CONTROL_CMD)</div>
<div class="line"> </div>
<div class="line">CommandHandler::handleCommand(type = CTRL_CMD_MESH_COMMAND)</div>
<div class="line"> </div>
<div class="line">CommandHandler::handleCmdMeshCommand({</div>
<div class="line">    meshCtrlCmd = {</div>
<div class="line">        header = {</div>
<div class="line">            type    = 0,</div>
<div class="line">            flags   = unicast &amp; acked,</div>
<div class="line">            idCount = 1,</div>
<div class="line">        },</div>
<div class="line">        targetIds      = [2],</div>
<div class="line">        controlCommand = {</div>
<div class="line">            type = CTRL_CMD_UART_MSG,</div>
<div class="line">            data = &quot;hi&quot;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">MeshMsgSender::handleSendMeshCommand()</div>
<div class="line"> </div>
<div class="line">MeshMsgSender::addToQueue({</div>
<div class="line">    type    = CS_MESH_MODEL_TYPE_CTRL_CMD,</div>
<div class="line">    payload = {</div>
<div class="line">        cmdType = CTRL_CMD_UART_MSG,</div>
<div class="line">        payload = &quot;hi&quot;</div>
<div class="line">    }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">MeshModelSelector::addToQueue()</div>
<div class="line">// Selects the MeshModelUnicast based on the mesh message flags.</div>
<div class="line"> </div>
<div class="line">MeshModelUnicast::addToQueue()</div>
<div class="line"> </div>
<div class="line">MeshModelUnicast::sendMsgFromQueue()</div>
<div class="line"> </div>
<div class="line">MeshModelUnicast::sendMsg({</div>
<div class="line">    msg = [ CS_MESH_MODEL_TYPE_CTRL_CMD, CTRL_CMD_UART_MSG, &quot;h&quot;, &quot;i&quot; ]</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">access_model_reliable_publish({</div>
<div class="line">    opcode  = CS_MESH_MODEL_OPCODE_UNICAST_RELIABLE_MSG,</div>
<div class="line">    message = [ CS_MESH_MODEL_TYPE_CTRL_CMD, CTRL_CMD_UART_MSG, &quot;h&quot;, &quot;i&quot; ]</div>
<div class="line">})</div>
</div><!-- fragment --><p> In this case, where the control command is a UART message, a generic control command mesh message of type <code>CS_MESH_MODEL_TYPE_CTRL_CMD</code> is sent, with the control command type as payload. For some control commands, there is a dedicated mesh message. For example: if the control command is <code>CTRL_CMD_SET_TIME</code>, a mesh message of type <code>CS_MESH_MODEL_TYPE_CMD_TIME</code> is sent instead. This is decided in the function <code>MeshMsgSender::handleSendMeshCommand</code>.</p>
<p >Now that the mesh message has been sent, <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 2 receives the message: </p><div class="fragment"><div class="line">MeshModelUnicast::handleMsg({</div>
<div class="line">    opcode  = CS_MESH_MODEL_OPCODE_UNICAST_RELIABLE_MSG,</div>
<div class="line">    message = [ CS_MESH_MODEL_TYPE_CTRL_CMD, CTRL_CMD_UART_MSG, &quot;h&quot;, &quot;i&quot; ]</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">MeshMsgHandler::handleMsg({</div>
<div class="line">    msg = {</div>
<div class="line">        opcode  = CS_MESH_MODEL_OPCODE_UNICAST_RELIABLE_MSG,</div>
<div class="line">        message = [ CS_MESH_MODEL_TYPE_CTRL_CMD, CTRL_CMD_UART_MSG, &quot;h&quot;, &quot;i&quot; ]</div>
<div class="line">    },</div>
<div class="line">    reply = {</div>
<div class="line">        type     = CS_MESH_MODEL_TYPE_UNKNOWN,</div>
<div class="line">        buf      = [0, 0, 0, 0, 0, 0, 0, 0],</div>
<div class="line">        dataSize = 0</div>
<div class="line">    }</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">MeshMsgHandler::handleControlCommand()</div>
<div class="line">    retCode        := CommandHandler::handleCmdUartMsg(commandData = &quot;hi&quot;)</div>
<div class="line">    shortRetCode   := MeshUtil::getShortenedRetCode(retCode)</div>
<div class="line">    reply.type     := CS_MESH_MODEL_TYPE_RESULT</div>
<div class="line">    reply.buf      := [ CS_MESH_MODEL_TYPE_CTRL_CMD, shortRetCode, CTRL_CMD_UART_MSG ]</div>
<div class="line">    reply.dataSize := 4</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">// Resuming in MeshModelUnicast::handleMsg</div>
<div class="line">MeshModelUnicast::sendReply({</div>
<div class="line">    msg = [ CS_MESH_MODEL_TYPE_RESULT, CS_MESH_MODEL_TYPE_CTRL_CMD, shortRetCode, CTRL_CMD_UART_MSG ]</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">access_model_reply({</div>
<div class="line">    accessReplyMsg = {</div>
<div class="line">        opcode = CS_MESH_MODEL_OPCODE_UNICAST_REPLY,</div>
<div class="line">        p_buffer = [ CS_MESH_MODEL_TYPE_RESULT, CS_MESH_MODEL_TYPE_CTRL_CMD, shortRetCode, CTRL_CMD_UART_MSG ]</div>
<div class="line">    }</div>
<div class="line">})</div>
</div><!-- fragment --><p> When the reply is not NULL in the <code>MeshMsgHandler::handleMsg</code> function, a reply will be sent after the message has been handled. The handler has to set the reply, this can be anything. The <code>reply</code> passed to <code>MeshMsgHandler::handleMsg</code> is initialized with type <code>CS_MESH_MODEL_TYPE_UNKNOWN</code> so that if no reply is set by the handler, no bogus mesh message will be sent.</p>
<p >Now that the reply has been sent, <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> 1 receives the reply: </p><div class="fragment"><div class="line">MeshModelUnicast::handleMsg({</div>
<div class="line">    srcAddress = 2,</div>
<div class="line">    opcode     = CS_MESH_MODEL_OPCODE_UNICAST_REPLY,</div>
<div class="line">    message    = [ CS_MESH_MODEL_TYPE_RESULT, CS_MESH_MODEL_TYPE_CTRL_CMD, shortRetCode, CTRL_CMD_UART_MSG ]</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">MeshMsgHandler::handleMsg({</div>
<div class="line">    msg = {</div>
<div class="line">        srcAddress = 2</div>
<div class="line">        opcode     = CS_MESH_MODEL_OPCODE_UNICAST_REPLY,</div>
<div class="line">        message    = [ CS_MESH_MODEL_TYPE_RESULT, CS_MESH_MODEL_TYPE_CTRL_CMD, shortRetCode, CTRL_CMD_UART_MSG ]</div>
<div class="line">    },</div>
<div class="line">    reply = NULL</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">MeshMsgHandler::handleResult(message, srcId = srcAddress)</div>
<div class="line">    resultHeader := {</div>
<div class="line">        stoneId = srcId</div>
<div class="line">        returnCode = MeshUtil::getInflatedRetCode(shortRetCode)</div>
<div class="line">        commandType = CTRL_CMD_UART_MSG</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">sendResultToUart(resultHeader)</div>
<div class="line"> </div>
<div class="line">UartHandler::writeMsg(UART_OPCODE_TX_MESH_RESULT, resultHeader)</div>
<div class="line"> </div>
<div class="line">// Resuming in MeshModelUnicast:handleMsg</div>
<div class="line">MeshModelUnicast::checkDone()</div>
<div class="line">    ackResult := {</div>
<div class="line">        commandType = CTRL_CMD_UNKNOWN,</div>
<div class="line">        returnCode  = ERR_SUCCESS</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">UartHandler::writeMsg(UART_OPCODE_TX_MESH_ACK_ALL_RESULT, ackResult)</div>
</div><!-- fragment --><p> Because a different opcode is used for a reply, the mesh model knows to treat it differently. The reply message is handled like any other mesh message.</p>
<p >With the current implementation, the reply to all mesh message types (except <code>CS_MESH_MODEL_TYPE_STONE_MAC</code>) are of type <code>CS_MESH_MODEL_TYPE_RESULT</code>. The function <code>MeshMsgHandler::handleResult</code> expects to be able to determine a control command type, result code, and optionally result data, from the received message. In this case, it will read the control command type directly from the message payload. But in other cases it determines it based on the mesh message type in the result message payload.</p>
<p >The last <code>ackResult</code> is not well implemented yet: it should set the correct returnCode and commandType. This is because the ackResult comes from the mesh model, which doesn't know anything about the message contents, except for the mesh message type. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
