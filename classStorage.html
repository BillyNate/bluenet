<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bluenet: Storage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
	DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bluenet
   &#160;<span id="projectnumber">5.4.0</span>
   </div>
   <div id="projectbrief">Bluenet, the firmware for the Crownstone power outlet</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classStorage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classStorage-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Storage Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to store items persistently in flash (persistent) memory.  
 <a href="classStorage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cs__Storage_8h_source.html">cs_Storage.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab484853b0ad4d95f890399394ffa0d49"><td class="memItemLeft" align="right" valign="top"><a id="ab484853b0ad4d95f890399394ffa0d49"></a>
cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="separator:ab484853b0ad4d95f890399394ffa0d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f04f8d88cc9064b8ddfb8b84e15a5a7"><td class="memItemLeft" align="right" valign="top"><a id="a8f04f8d88cc9064b8ddfb8b84e15a5a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInitialized</b> ()</td></tr>
<tr class="separator:a8f04f8d88cc9064b8ddfb8b84e15a5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55559029c4659a23ca3f6e859cbd944b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a55559029c4659a23ca3f6e859cbd944b">setErrorCallback</a> (cs_storage_error_callback_t callback)</td></tr>
<tr class="memdesc:a55559029c4659a23ca3f6e859cbd944b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback for errors.  <a href="classStorage.html#a55559029c4659a23ca3f6e859cbd944b">More...</a><br /></td></tr>
<tr class="separator:a55559029c4659a23ca3f6e859cbd944b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a21e4c167563c15d0d4e255406a3212"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a9a21e4c167563c15d0d4e255406a3212">findFirst</a> (CS_TYPE type, cs_state_id_t &amp;id)</td></tr>
<tr class="memdesc:a9a21e4c167563c15d0d4e255406a3212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first id of stored values of given type.  <a href="classStorage.html#a9a21e4c167563c15d0d4e255406a3212">More...</a><br /></td></tr>
<tr class="separator:a9a21e4c167563c15d0d4e255406a3212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af463d6bdd483b6ca5b20d9c7086eaf33"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#af463d6bdd483b6ca5b20d9c7086eaf33">findNext</a> (CS_TYPE type, cs_state_id_t &amp;id)</td></tr>
<tr class="memdesc:af463d6bdd483b6ca5b20d9c7086eaf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find next id of stored values of given type.  <a href="classStorage.html#af463d6bdd483b6ca5b20d9c7086eaf33">More...</a><br /></td></tr>
<tr class="separator:af463d6bdd483b6ca5b20d9c7086eaf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc71decf58d7c48b542093c09a3e3cc"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a6cc71decf58d7c48b542093c09a3e3cc">read</a> (<a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a6cc71decf58d7c48b542093c09a3e3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and read stored value of given type and id.  <a href="classStorage.html#a6cc71decf58d7c48b542093c09a3e3cc">More...</a><br /></td></tr>
<tr class="separator:a6cc71decf58d7c48b542093c09a3e3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942cc45bfc646e39262a7f58bf715941"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a942cc45bfc646e39262a7f58bf715941">readV3ResetCounter</a> (<a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a942cc45bfc646e39262a7f58bf715941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the old (v3) reset counter.  <a href="classStorage.html#a942cc45bfc646e39262a7f58bf715941">More...</a><br /></td></tr>
<tr class="separator:a942cc45bfc646e39262a7f58bf715941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7badd0c226f7e7c697f26925cef85cb3"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a7badd0c226f7e7c697f26925cef85cb3">readFirst</a> (<a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a7badd0c226f7e7c697f26925cef85cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and read from first stored value of given type.  <a href="classStorage.html#a7badd0c226f7e7c697f26925cef85cb3">More...</a><br /></td></tr>
<tr class="separator:a7badd0c226f7e7c697f26925cef85cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199c8b467084c584432d6425fb56090e"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a199c8b467084c584432d6425fb56090e">readNext</a> (<a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a199c8b467084c584432d6425fb56090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and read next stored value of given type.  <a href="classStorage.html#a199c8b467084c584432d6425fb56090e">More...</a><br /></td></tr>
<tr class="separator:a199c8b467084c584432d6425fb56090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436faa3b72e4ae2a2ddbe0d1632c18f4"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a436faa3b72e4ae2a2ddbe0d1632c18f4">write</a> (const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;data)</td></tr>
<tr class="memdesc:a436faa3b72e4ae2a2ddbe0d1632c18f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to persistent storage.  <a href="classStorage.html#a436faa3b72e4ae2a2ddbe0d1632c18f4">More...</a><br /></td></tr>
<tr class="separator:a436faa3b72e4ae2a2ddbe0d1632c18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4145914b7aadf27c6eecdd436e7e6e90"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a4145914b7aadf27c6eecdd436e7e6e90">remove</a> (CS_TYPE type, cs_state_id_t id)</td></tr>
<tr class="memdesc:a4145914b7aadf27c6eecdd436e7e6e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove value of given type and id.  <a href="classStorage.html#a4145914b7aadf27c6eecdd436e7e6e90">More...</a><br /></td></tr>
<tr class="separator:a4145914b7aadf27c6eecdd436e7e6e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904b54728ed95290d85a5c75ff5a95d1"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a904b54728ed95290d85a5c75ff5a95d1">remove</a> (CS_TYPE type)</td></tr>
<tr class="memdesc:a904b54728ed95290d85a5c75ff5a95d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all values of a type.  <a href="classStorage.html#a904b54728ed95290d85a5c75ff5a95d1">More...</a><br /></td></tr>
<tr class="separator:a904b54728ed95290d85a5c75ff5a95d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2882ca4fe58adf4ce15473136954f7e"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ad2882ca4fe58adf4ce15473136954f7e">remove</a> (cs_state_id_t id)</td></tr>
<tr class="memdesc:ad2882ca4fe58adf4ce15473136954f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all values with given id.  <a href="classStorage.html#ad2882ca4fe58adf4ce15473136954f7e">More...</a><br /></td></tr>
<tr class="separator:ad2882ca4fe58adf4ce15473136954f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24075dd8de7eacaed8382ae0969e6d72"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a24075dd8de7eacaed8382ae0969e6d72">factoryReset</a> ()</td></tr>
<tr class="memdesc:a24075dd8de7eacaed8382ae0969e6d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform factory reset.  <a href="classStorage.html#a24075dd8de7eacaed8382ae0969e6d72">More...</a><br /></td></tr>
<tr class="separator:a24075dd8de7eacaed8382ae0969e6d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eaf15b6ac5bb3801938bfe82fb67ea"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a67eaf15b6ac5bb3801938bfe82fb67ea">garbageCollect</a> ()</td></tr>
<tr class="memdesc:a67eaf15b6ac5bb3801938bfe82fb67ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collection reclaims the flash space that is occupied by records that have been deleted, or that failed to be completely written due to, for example, a power loss.  <a href="classStorage.html#a67eaf15b6ac5bb3801938bfe82fb67ea">More...</a><br /></td></tr>
<tr class="separator:a67eaf15b6ac5bb3801938bfe82fb67ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8712e3516b8c402951b4c09313ed4d"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#abf8712e3516b8c402951b4c09313ed4d">eraseAllPages</a> ()</td></tr>
<tr class="memdesc:abf8712e3516b8c402951b4c09313ed4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all flash pages used by FDS.  <a href="classStorage.html#abf8712e3516b8c402951b4c09313ed4d">More...</a><br /></td></tr>
<tr class="separator:abf8712e3516b8c402951b4c09313ed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0be0a19866eaf63a653e37b002eb0d0"><td class="memItemLeft" align="right" valign="top">cs_ret_code_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ac0be0a19866eaf63a653e37b002eb0d0">erasePages</a> (const CS_TYPE doneEvent, void *startAddress, void *endAddress)</td></tr>
<tr class="memdesc:ac0be0a19866eaf63a653e37b002eb0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase flash pages.  <a href="classStorage.html#ac0be0a19866eaf63a653e37b002eb0d0">More...</a><br /></td></tr>
<tr class="separator:ac0be0a19866eaf63a653e37b002eb0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe5c42f19de3b98885659d4ae40d853"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a0fe5c42f19de3b98885659d4ae40d853">allocate</a> (size16_t &amp;size)</td></tr>
<tr class="memdesc:a0fe5c42f19de3b98885659d4ae40d853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate ram that is correctly aligned and padded.  <a href="classStorage.html#a0fe5c42f19de3b98885659d4ae40d853">More...</a><br /></td></tr>
<tr class="separator:a0fe5c42f19de3b98885659d4ae40d853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f80aa3da98c94041432f992fe18cf7"><td class="memItemLeft" align="right" valign="top"><a id="aa6f80aa3da98c94041432f992fe18cf7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#aa6f80aa3da98c94041432f992fe18cf7">handleFileStorageEvent</a> (fds_evt_t const *p_fds_evt)</td></tr>
<tr class="memdesc:aa6f80aa3da98c94041432f992fe18cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle FDS events. <br /></td></tr>
<tr class="separator:aa6f80aa3da98c94041432f992fe18cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b7bf4d475ed3578c2017f9a79dbbe"><td class="memItemLeft" align="right" valign="top"><a id="acf5b7bf4d475ed3578c2017f9a79dbbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#acf5b7bf4d475ed3578c2017f9a79dbbe">handleFlashOperationSuccess</a> ()</td></tr>
<tr class="memdesc:acf5b7bf4d475ed3578c2017f9a79dbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle FDS SOC event NRF_EVT_FLASH_OPERATION_SUCCESS. <br /></td></tr>
<tr class="separator:acf5b7bf4d475ed3578c2017f9a79dbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad665b0e9ba881019d07479acdbda2a78"><td class="memItemLeft" align="right" valign="top"><a id="ad665b0e9ba881019d07479acdbda2a78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#ad665b0e9ba881019d07479acdbda2a78">handleFlashOperationError</a> ()</td></tr>
<tr class="memdesc:ad665b0e9ba881019d07479acdbda2a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle FDS SOC event NRF_EVT_FLASH_OPERATION_ERROR. <br /></td></tr>
<tr class="separator:ad665b0e9ba881019d07479acdbda2a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a05f07d13f65b0258c57a22c29fd4e3e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classStorage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorage.html#a05f07d13f65b0258c57a22c29fd4e3e8">getInstance</a> ()</td></tr>
<tr class="memdesc:a05f07d13f65b0258c57a22c29fd4e3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the singleton instance of this class.  <a href="classStorage.html#a05f07d13f65b0258c57a22c29fd4e3e8">More...</a><br /></td></tr>
<tr class="separator:a05f07d13f65b0258c57a22c29fd4e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to store items persistently in flash (persistent) memory. </p>
<p>This class provides functions to initialize, clear, write and read persistent memory (flash) through the use of Flash Data <a class="el" href="classStorage.html" title="Class to store items persistently in flash (persistent) memory.">Storage</a>.</p>
<p>The information on the Flash Data <a class="el" href="classStorage.html" title="Class to store items persistently in flash (persistent) memory.">Storage</a> from Nordic can be found at the link: <a href="https://www.nordicsemi.com/DocLib/Content/SDK_Doc/nRF5_SDK/v15-2-0/lib_fds">https://www.nordicsemi.com/DocLib/Content/SDK_Doc/nRF5_SDK/v15-2-0/lib_fds</a> old: <a href="https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk%2Fdita%2Fsdk%2Fnrf5_sdk.html">https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.sdk%2Fdita%2Fsdk%2Fnrf5_sdk.html</a></p>
<p>CS_TYPE is used as record key.</p>
<p>Garbage collection will be automatically started by this class when needed.</p>
<p>When a record is corrupted, most likely in case of power loss while writing, the CRC check will fail when opening a file. In this case the record will be deleted (TODO).</p>
<p>Only one record for each record key should exist. In case there are multiple (duplicates), they will be removed (TODO). Since FDS always appends records, it is assumed that the last valid record should be kept. Checking for duplicates is done for each write and each read.</p>
<p>Some operations will block other operations. For example, you can't write a record while performing garbage collection. You can't write a record while it's already being written. This is what the "busy" functions are for. Each type can be set busy multiple times, for example in case multiple records of the same type are being deleted.</p>
<p>FDS internally uses events NRF_EVT_FLASH_OPERATION_SUCCESS and NRF_EVT_FLASH_OPERATION_ERROR. These events don't give any context of the operation, so it is not adviced to use FDS together with something else that writes to flash (like Flash Manager). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0fe5c42f19de3b98885659d4ae40d853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe5c42f19de3b98885659d4ae40d853">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* Storage::allocate </td>
          <td>(</td>
          <td class="paramtype">size16_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate ram that is correctly aligned and padded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>Requested size, afterwards set to the allocated size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated memory. </dd></dl>

</div>
</div>
<a id="abf8712e3516b8c402951b4c09313ed4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8712e3516b8c402951b4c09313ed4d">&#9670;&nbsp;</a></span>eraseAllPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::eraseAllPages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all flash pages used by FDS. </p>
<p>This should only be used to recover from a failing init.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successfully started erasing all pages. </td></tr>
    <tr><td class="paramname">ERR_NOT_AVAILABLE</td><td>When you can't use this function (storage initialized already). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0be0a19866eaf63a653e37b002eb0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0be0a19866eaf63a653e37b002eb0d0">&#9670;&nbsp;</a></span>erasePages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::erasePages </td>
          <td>(</td>
          <td class="paramtype">const CS_TYPE&#160;</td>
          <td class="paramname"><em>doneEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>endAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase flash pages. </p>
<p>Must be called before storage is initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">doneEvent</td><td>Type of event that should be sent when pages have been erased. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startAddress</td><td>Address of first page to erase. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endAddress</td><td>Address of first page <b>not</b> to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successfully started erasing all pages. </td></tr>
    <tr><td class="paramname">ERR_NOT_AVAILABLE</td><td>When you can't use this function (storage initialized already). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24075dd8de7eacaed8382ae0969e6d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24075dd8de7eacaed8382ae0969e6d72">&#9670;&nbsp;</a></span>factoryReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::factoryReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform factory reset. </p>
<p>Make sure to restart factory reset on any error callback.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_WAIT_FOR_SUCCESS</td><td>Successfully started removing a record. </td></tr>
    <tr><td class="paramname">ERR_SUCCESS</td><td>All records have been removed. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>Busy, try again later. </td></tr>
    <tr><td class="paramname">other</td><td>Other errors, maybe retry again later? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a21e4c167563c15d0d4e255406a3212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a21e4c167563c15d0d4e255406a3212">&#9670;&nbsp;</a></span>findFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::findFirst </td>
          <td>(</td>
          <td class="paramtype">CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs_state_id_t &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first id of stored values of given type. </p>
<p>NOTE: you should complete or abort this <a class="el" href="classStorage.html#a9a21e4c167563c15d0d4e255406a3212" title="Find first id of stored values of given type.">findFirst()</a> / <a class="el" href="classStorage.html#af463d6bdd483b6ca5b20d9c7086eaf33" title="Find next id of stored values of given type.">findNext()</a> before starting a new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type to search for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>ID of the found value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successful. </td></tr>
    <tr><td class="paramname">ERR_NOT_FOUND</td><td>When the first id of this type was not found. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af463d6bdd483b6ca5b20d9c7086eaf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af463d6bdd483b6ca5b20d9c7086eaf33">&#9670;&nbsp;</a></span>findNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::findNext </td>
          <td>(</td>
          <td class="paramtype">CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs_state_id_t &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find next id of stored values of given type. </p>
<p>NOTE: must be called immediately after <a class="el" href="classStorage.html#a9a21e4c167563c15d0d4e255406a3212" title="Find first id of stored values of given type.">findFirst()</a>, no other storage operations should be done in between.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type to search for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>ID of the found value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successful. </td></tr>
    <tr><td class="paramname">ERR_NOT_FOUND</td><td>When the next id of this type was not found. </td></tr>
    <tr><td class="paramname">ERR_WRONG_STATE</td><td>When not called after <a class="el" href="classStorage.html#a9a21e4c167563c15d0d4e255406a3212" title="Find first id of stored values of given type.">findFirst()</a>, or another storage operation was done in between. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67eaf15b6ac5bb3801938bfe82fb67ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67eaf15b6ac5bb3801938bfe82fb67ea">&#9670;&nbsp;</a></span>garbageCollect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::garbageCollect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Garbage collection reclaims the flash space that is occupied by records that have been deleted, or that failed to be completely written due to, for example, a power loss. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successfully started garbage collection. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05f07d13f65b0258c57a22c29fd4e3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f07d13f65b0258c57a22c29fd4e3e8">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classStorage.html">Storage</a>&amp; Storage::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the singleton instance of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>static instance of <a class="el" href="classStorage.html" title="Class to store items persistently in flash (persistent) memory.">Storage</a> class </dd></dl>

</div>
</div>
<a id="a6cc71decf58d7c48b542093c09a3e3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc71decf58d7c48b542093c09a3e3cc">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and read stored value of given type and id. </p>
<p>In case of duplicates (values with same type and id), you will get the latest value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data struct with type and id to read. Pointer and size will be set afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successful. </td></tr>
    <tr><td class="paramname">ERR_NOT_FOUND</td><td>When the type was not found. </td></tr>
    <tr><td class="paramname">ERR_WRONG_PAYLOAD_LENGTH</td><td>When the given size does not match the stored size. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7badd0c226f7e7c697f26925cef85cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7badd0c226f7e7c697f26925cef85cb3">&#9670;&nbsp;</a></span>readFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::readFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and read from first stored value of given type. </p>
<p>NOTE: you should complete or abort this <a class="el" href="classStorage.html#a7badd0c226f7e7c697f26925cef85cb3" title="Find and read from first stored value of given type.">readFirst()</a> / <a class="el" href="classStorage.html#a199c8b467084c584432d6425fb56090e" title="Find and read next stored value of given type.">readNext()</a> before starting a new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data struct with type to read. ID, pointer, and size will be set afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successful. </td></tr>
    <tr><td class="paramname">ERR_NOT_FOUND</td><td>When the type was not found. </td></tr>
    <tr><td class="paramname">ERR_WRONG_PAYLOAD_LENGTH</td><td>When the given size does not match the stored size. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a199c8b467084c584432d6425fb56090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199c8b467084c584432d6425fb56090e">&#9670;&nbsp;</a></span>readNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::readNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and read next stored value of given type. </p>
<p>NOTE: must be called immediately after <a class="el" href="classStorage.html#a7badd0c226f7e7c697f26925cef85cb3" title="Find and read from first stored value of given type.">readFirst()</a>, no other storage operations should be done in between.</p>
<p>When iterating: just keep overwriting, so in case of duplicates (same type and id), you end up with the latest value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data struct with type to read. ID, pointer, and size will be set afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successful. </td></tr>
    <tr><td class="paramname">ERR_NOT_FOUND</td><td>When the type was not found. </td></tr>
    <tr><td class="paramname">ERR_WRONG_PAYLOAD_LENGTH</td><td>When the given size does not match the stored size. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a942cc45bfc646e39262a7f58bf715941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942cc45bfc646e39262a7f58bf715941">&#9670;&nbsp;</a></span>readV3ResetCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::readV3ResetCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the old (v3) reset counter. </p>
<p>Made to transfer reset counter from old location to new.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Data struct with type and id to read. Pointer and size will be set afterwards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code like <a class="el" href="classStorage.html#a6cc71decf58d7c48b542093c09a3e3cc" title="Find and read stored value of given type and id.">read()</a>. </dd></dl>

</div>
</div>
<a id="ad2882ca4fe58adf4ce15473136954f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2882ca4fe58adf4ce15473136954f7e">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::remove </td>
          <td>(</td>
          <td class="paramtype">cs_state_id_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all values with given id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the values to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successfully started removing. </td></tr>
    <tr><td class="paramname">ERR_NOT_FOUND</td><td>When no match was not found, consider this a success, but don't wait for an event. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
    <tr><td class="paramname">ERR_NOT_INITIALIZED</td><td>When storage hasn't been initialized yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a904b54728ed95290d85a5c75ff5a95d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904b54728ed95290d85a5c75ff5a95d1">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::remove </td>
          <td>(</td>
          <td class="paramtype">CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all values of a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successfully started removing the type. </td></tr>
    <tr><td class="paramname">ERR_NOT_FOUND</td><td>When no match was not found, consider this a success, but don't wait for an event. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
    <tr><td class="paramname">ERR_NOT_INITIALIZED</td><td>When storage hasn't been initialized yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4145914b7aadf27c6eecdd436e7e6e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4145914b7aadf27c6eecdd436e7e6e90">&#9670;&nbsp;</a></span>remove() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::remove </td>
          <td>(</td>
          <td class="paramtype">CS_TYPE&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cs_state_id_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove value of given type and id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type to remove. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of value to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successfully started removing the value. </td></tr>
    <tr><td class="paramname">ERR_NOT_FOUND</td><td>When no match was found, consider this a success, but don't wait for an event. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
    <tr><td class="paramname">ERR_NOT_INITIALIZED</td><td>When storage hasn't been initialized yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55559029c4659a23ca3f6e859cbd944b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55559029c4659a23ca3f6e859cbd944b">&#9670;&nbsp;</a></span>setErrorCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Storage::setErrorCallback </td>
          <td>(</td>
          <td class="paramtype">cs_storage_error_callback_t&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the callback for errors. </p>
<p>These are errors like timeouts, that come in after a write/read/remove function returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to be called when an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a436faa3b72e4ae2a2ddbe0d1632c18f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436faa3b72e4ae2a2ddbe0d1632c18f4">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cs_ret_code_t Storage::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcs__state__data__t.html">cs_state_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to persistent storage. </p>
<p>It is assumed that data pointer was allocated by this class.</p>
<p>Automatically starts garbage collection when needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data struct with type, data pointer, and size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ERR_SUCCESS</td><td>When successfully started to write. </td></tr>
    <tr><td class="paramname">ERR_BUSY</td><td>When busy, try again later. </td></tr>
    <tr><td class="paramname">ERR_NO_SPACE</td><td>When there is no space, not even after garbage collection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/include/drivers/<a class="el" href="cs__Storage_8h_source.html">cs_Storage.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classStorage.html">Storage</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
