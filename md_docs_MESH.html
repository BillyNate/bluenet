<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bluenet: Mesh</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
	DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bluenet
   &#160;<span id="projectnumber">5.4.0</span>
   </div>
   <div id="projectbrief">Bluenet, the firmware for the Crownstone power outlet</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_MESH.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >The bluenet firmware supports Bluetooth <a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a>. On top of Bluetooth <a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a> (spec, <a href="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=457092">pdf</a>) we have defined a protocol, which can be found <a class="el" href="md_docs_protocol_MESH_PROTOCOL.html">here</a>.</p>
<p >Bluetooth mesh uses <b>flooding</b>. Each node broadcasts to all its neighbouring nodes. All authenticated network packets it receives (and that are not in the message cache) are retransmitted with a time-to-live (TTL) counter that is decrementing with each hop.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">layer   </th><th class="markdownTableHeadNone">function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">model   </td><td class="markdownTableBodyNone">application-level (e.g. a Light Lightness Model)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">access   </td><td class="markdownTableBodyNone">encrypted communication (application level), data verification    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">upper transport   </td><td class="markdownTableBodyNone">encrypted communication (application/device level), transport control (heartbeat)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lower transport   </td><td class="markdownTableBodyNone">reliable mechanism (acknowledgements), desegmentation and segmentation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">network   </td><td class="markdownTableBodyNone">encrypted on the network level, defines how to relay    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">bearer   </td><td class="markdownTableBodyNone">mesh packets (protocol data units or PDUs) which implement an advertising bearer and a GATT bearer    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BLE   </td><td class="markdownTableBodyNone">the Bluetooth LE stack   </td></tr>
</table>
<p >There are also some special roles for nodes in a Bluetooth <a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">node   </th><th class="markdownTableHeadNone">function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">relay   </td><td class="markdownTableBodyNone">retransmit incoming messages    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">low-power   </td><td class="markdownTableBodyNone">reduce duty-cycle to save energy    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">friend   </td><td class="markdownTableBodyNone">save messages intended for low-power nodes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">proxy   </td><td class="markdownTableBodyNone">implement access to the mesh for non-mesh Bluetooth LE devices   </td></tr>
</table>
<p >The bluenet firmware is intended for behind power outlets: sufficient power! Hence, each node is a <b>relay</b>. Those <b>low-power</b> nodes need <b>friend</b> nodes to save their messages for them when they wake up. This is not necessary for our use case. The firmware also does not implement the <b>proxy</b> role (the GATT bearer at the bearer level). The bluenet firmware already defines services and characteristics to interface with the firmware. This would only add a second redundant route and increase required memory resources.</p>
<h1><a class="anchor" id="autotoc_md40"></a>
Encryption</h1>
<p >There are three levels of encryption:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">key   </th><th class="markdownTableHeadNone">function    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">network   </td><td class="markdownTableBodyNone">be able to relay messages in the mesh but cannot access application data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">application   </td><td class="markdownTableBodyNone">encrypt/decrypt between e.g. light switches and light bulbs and no other applications (only valid within the same mesh)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">secures communication between a yet unprovisioned device and a provisioner   </td></tr>
</table>
<p >It is a very nice feature of Bluetooth mesh that it is possible to relay data for other applications without the ability to inspect that data.</p>
<p >The protocol defines a mechanism for the removal of a node. Regretfully this does not anything sophisticated from the broadcast encryption literature. It requires redistribution of new network keys and application keys to all remaining nodes that are not put on the blacklist.</p>
<p >A privacy key can be derived from the network key to obfuscate, for example, a source address. Due to it being derived from the network key, other nodes in the mesh can decrypt it.</p>
<p >Replay attacks are countered by a sequence number (SEQ) and an initialization vector (IV) index. A message is only accepted if it is sufficiently new (brought about by simple incrementing). The SEQ (3 bytes) is actually send over the air and the IV (4 bytes) is only very slowly changing and considered to be known by the network.</p>
<p >The encryption itself is done through AES-CCM (just as Bluetooth LE).</p>
<h1><a class="anchor" id="autotoc_md41"></a>
Mesh messages</h1>
<p >This overview from silabs gives the best insight into segmentation.</p>
<p ><img src="../docs/images/silabs-bluetooth-segmentation.jpg" alt="Mesh segment" class="inline"/></p>
<p >Compare this image with the information below to get a grasp on the make-up of a packet.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
Mesh message packet</h2>
<p ><img src="../docs/diagrams/mesh-message-packet.png" alt="Mesh message packet" class="inline"/></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Length in bits   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">IVI   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Least significant bit of IV index    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">NID   </td><td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">Network-based ID. Derived from network key to indentify the mesh    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">CTL   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Access message versus control message    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">TTL   </td><td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone"><a class="el" href="classTime.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: Sep 24,...">Time</a> to live    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">SEQ   </td><td class="markdownTableBodyNone">24   </td><td class="markdownTableBodyNone">Sequence number    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">SRC   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">Source address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">DST   </td><td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">Destination address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">Transport PDU   </td><td class="markdownTableBodyNone">N   </td><td class="markdownTableBodyNone">Packet contents    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">NetMIC   </td><td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">Network Message Integrity Check (64 bits for a control message)   </td></tr>
</table>
<p >The first byte are in the clear, then there are a couple obfuscated, and destination and transport payload are encrypted. The transport PDU is of of a maximum size of 128 bits (16 bytes) for an access message and 96 bits (12 bytes) for a control message. The total message is 31 bytes.</p>
<p >The TTL can have a value of <code>0</code>. In that case the message will not be relayed. This means all receiving nodes will know that this message is a single radio link away. This can be used to build up a topology of the network.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Segmented message</h2>
<p >The transport payload can be separated into multiple segments. However, this eats a little bit from the payload to indicate the segment index and count. For our access messages with a transport PDU of 16 bytes:</p>
<p ><img src="../docs/diagrams/mesh-transport-pdu.png" alt="Mesh transport PDU" class="inline"/></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Length in bits   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">SEG=1   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">High bit means a segmented message    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">AKF   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Indicates the application layer key    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">AID   </td><td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">Defines the application layer key    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">SZMIC   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Indicates that the size of the NetMIC in the upper layer is 4 bytes (32 bits)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">SeqZero   </td><td class="markdownTableBodyNone">13   </td><td class="markdownTableBodyNone">Least significant bits of SeqAuth.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">SegO   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">Segment number of segment m    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">SegN   </td><td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">Maximum number of segments    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">Segment m   </td><td class="markdownTableBodyNone">96   </td><td class="markdownTableBodyNone">The segment itself (for last segment can be 8 up to 96 bits)   </td></tr>
</table>
<p >You see that a single segmented message contains 96 bits or only 12 bytes. It is actually even worse. Even that segment is not free to define.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Length in bits   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyNone">24   </td><td class="markdownTableBodyNone">A manufacturer-specific opcode starts with <code>11</code> and takes 3 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">Payload   </td><td class="markdownTableBodyNone">40   </td><td class="markdownTableBodyNone">Actual contents (5 bytes)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">TransMIC   </td><td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">Transport Message Integrity Check (4 bytes)   </td></tr>
</table>
<p >Note that there are only 5 bytes of actual contents left (8 bytes if you add the opcode)!</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Unsegmented message</h2>
<p >A single unsegmented message has slightly more space for data (because there is no segmentation overhead).</p>
<p ><img src="../docs/diagrams/mesh-transport-pdu-unsegmented.png" alt="Mesh transport PDU unsegmented" class="inline"/></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Length in bits   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">SEG=0   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Low bit means a segmented message    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">AKF   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Indicates the application layer key    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">AID   </td><td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">Defines the application layer key    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">Upper PDU   </td><td class="markdownTableBodyNone">120   </td><td class="markdownTableBodyNone">The upper transport access PDU   </td></tr>
</table>
<p >There are 120 bits (15 bytes). And again this is divided into:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Length in bits   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">Opcode   </td><td class="markdownTableBodyNone">24   </td><td class="markdownTableBodyNone">A manufacturer-specific opcode starts with <code>11</code> and takes 3 bytes.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">Payload   </td><td class="markdownTableBodyNone">64   </td><td class="markdownTableBodyNone">Actual contents (8 bytes)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">uint8   </td><td class="markdownTableBodyNone">TransMIC   </td><td class="markdownTableBodyNone">32   </td><td class="markdownTableBodyNone">Transport Message Integrity Check (4 bytes)   </td></tr>
</table>
<p >There are 64 bits for the message (8 bytes).</p>
<p >The <a class="el" href="md_docs_protocol_MESH_PROTOCOL.html">protocol</a> uses one byte for the message type which leaves 7 bytes for contents to be communicated over the mesh. Note that this not contain versioning. From the first byte starting with <code>11</code> we might use the remaining six to do versioning later on.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Mesh model</h2>
<p >Bluetooth mesh has predefined "mesh models", which are similar to Bluetooth services. A model "defines a set of States, State Transitions, State Bindings, Messages, and other associated behaviors". An example of a predefined model would be the "generic on/off" model.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
Group address</h2>
<p >In order to send a message to multiple nodes, a central device will add certain nodes to a group, by assigning a group address to those nodes. Each node can have multiple group addresses. Then, the destination address in the mesh message is set to a group address, and each node with that group address will handle the message.</p>
<p >An example that is given is to add all lights in a room to a group, so you can turn them all on/off at the same time.</p>
<h1><a class="anchor" id="autotoc_md47"></a>
nRF implementation details</h1>
<h2><a class="anchor" id="autotoc_md48"></a>
Radio access</h2>
<p >Underlying mesh as well as listening for or setting up Bluetooth connections, broadcasting Bluetooth LE advertisements, etc. is the same physical radio. Hence, we need <b>time multiplexing</b>.</p>
<p >The nRF5 SDK for <a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a> makes use of Soft Device time slot API. In short, it requests radio time to send mesh messages, and listen (scan) for incoming mesh messages.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Scanning</h2>
<p >The mesh stack implements a Bluetooth LE compliant <b>scanner</b>. This is enabled through:</p>
<div class="fragment"><div class="line">MESH_SCANNER = 1</div>
</div><!-- fragment --><p >We use actually a clone of the implementation on the Bluetooth <a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a> by Nordic (see <a href="https://github.com/crownstone/nRF5-SDK-for-Mesh">here</a>) which implements <b>active scanning</b>. The default is passive scanning which only listens on the radio for incoming advertisements. Active scanning means that the firmware asks for more information in the form of a <b>scan response request</b> and gets this information as a <b>scan response</b>.</p>
<p >Over the course of time broadcasts of advertisements on iOS are moving more and more data into scan responses. First, when having apps running in the background, but this might be now the case for apps running in the foreground as well. This is why those <b>scan response requests</b> are important to send out. The details of this can be found in the <a class="el" href="md_docs_protocol_BROADCAST_PROTOCOL.html">broadcast protocol</a>.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Advertising</h2>
<p >Because mesh messages are simply sent as advertisements, it made sense for the mesh SDK to also expose an advertising API. It lets the user send completely custom advertisements at an interval or a limited number of times.</p>
<p >The address we use for the Bluetooth <a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a> messages is decremented with one w.r.t. default factory address for the node. It is set to the same for all roles (but only the relay role is used).</p>
<div class="fragment"><div class="line">mesh_opt_core_adv_addr_set(role, address)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md51"></a>
Bluenet specific</h1>
<h2><a class="anchor" id="autotoc_md52"></a>
Self-provisioning</h2>
<p >Bluetooth mesh is quite complicated with respect to provisioning. The Crownstones already have a route to achieve keys. Hence, we require a way to use this out-of-band method to do the provisioning for mesh keys as well.</p>
<p >In the Nordic code, the DSM (device state manager) is responsible for storing the encryption keys and addresses used by the mesh. We obtain keys etc from persistent memory and define an address as being identical to a <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> ID.</p>
<div class="fragment"><div class="line">provisionSelf(uint16_t id)</div>
</div><!-- fragment --><p >This reduces the number of potential nodes from <code>2^16</code> to <code>2^8</code>. There are a couple of places from which this limitation stems:</p>
<ul>
<li>To send RSSI reports between two nodes we currently require 5 bytes, using <code>uint16_t</code> would push it to 7 bytes which would require us to drop or compression meta-info about the channel for example.</li>
<li>To send a multi-switch message (this only switches a single <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> though) we use 7 bytes. It allows to execute with a delay using a timestamp of 2 bytes and it specifies the source of the command (switchcraft, connection, internal, etc.) including a counter with 3 bytes. Going to <code>uint16_t</code> would require e.g. compression of the delay field (e.g. using the high bit to indicate two different time regimes).</li>
</ul>
<h2><a class="anchor" id="autotoc_md53"></a>
Models</h2>
<p >Currently, bluenet only has <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> specific models that all send the same <a class="el" href="md_docs_protocol_MESH_PROTOCOL.html">messages</a>, but differ in whether they send reliable (acked) messages, whether they send unicast or broadcast messages, and the TTL with which they send the messages.</p>
<p >Each model has its own queue of messages to be sent. Every model that sends acked messages, handle them 1 by 1: the next message will be sent when the previous is acked or timed out. The unacked model interleaves messages from the queue. Every period it sends a burst of messages from the queue. For example if there are 5 messages queued, the sent messages will look something like this: </p><div class="fragment"><div class="line">[00:00:00] Send messages 1, 2, 3</div>
<div class="line">[00:00:00] Send messages 4, 5, 1</div>
<div class="line">[00:00:00] Send messages 2, 3, 4</div>
<div class="line">...</div>
</div><!-- fragment --><p> The reason we interleave them is to decrease the latency (every message is sent as soon as possible), while keeping the reliability (every messsage is sent multiple times).</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Group addresses</h2>
<p >The models that send and receive broadcast messages, assign a predefined group address to the <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a>. This way, all crownstones can handle the message.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Advertising</h2>
<p >A <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> advertises with 3 MACs:</p>
<ul>
<li><a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a> messages (using MAC decremented by 1). Bluetooth mesh messages are sent as advertisements by design.</li>
<li>iBeacon advertisements (using MAC incremented by 1).</li>
<li>Regular advertisements, contain: connectable flag, name, and service data.</li>
</ul>
<p >The reason multiple MAC addresses are used, is so phones (or other devices) are not confused by whether they can connect or not to the <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a>.</p>
<h3><a class="anchor" id="autotoc_md56"></a>
Details</h3>
<p >The advertiser in the mesh directory (see <code>cs_Mesh.cpp</code> and <code>cs_MeshAdvertiser.cpp</code>) makes use of the advertiser implemented in the mesh SDK. It is set to a mac address incremented with one w.r.t. default factory address:</p>
<div class="fragment"><div class="line">_advertiser.setMacAddress(address)</div>
</div><!-- fragment --><p >This advertiser is responsible for broadcasting iBeacon messages (it can even iterate through a couple of them). The reason we use the mesh SDK for this, is because it operates completely separate from the softdevice, and thus can use a different MAC. Next to that, the softdevice doesn't have to be reconfigured all the time to interleave iBeacon and service data advertisements.</p>
<p >The <code><a class="el" href="classAdvertiser.html">Advertiser</a></code> class defined in <code>cs_Advertiser.cpp</code> is responsible for broadcasting advertisements (and scan responses) with <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> service data. This advertiser sends out <b>connectable advertisements</b>. It is not possible to do that with the advertiser in the mesh SDK, as the softdevice handles connections which are linked to the connectable flag in the advertisement.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Synchronizing</h2>
<p >There is specific functionality built on top of Bluetooth <a class="el" href="classMesh.html" title="Author: Crownstone Team Copyright: Crownstone (https://crownstone.rocks) Date: 12 Apr....">Mesh</a>, e.g. for the synchronization of a single clock. At boot, a <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> will send requests for synchronization. Once running, the synchronization happens at an interval.</p>
<p >The configuration for this can be found in <code><a class="el" href="cs__Config_8h_source.html">cs_Config.h</a></code>:</p>
<ul>
<li>How often time is sent into the mesh (50 seconds)</li>
<li>Variation with respect to this interval (20 seconds)</li>
<li>How often <a class="el" href="classCrownstone.html" title="Crownstone encapsulates all functionality, stack, services, and configuration.">Crownstone</a> state is sent into the mesh (50 seconds)</li>
<li>Variations with respect to this interval (20 seconds)</li>
<li>How often synchronization requests are sent into the mesh (2.5 seconds)</li>
<li>When synchronization is given up (after 60 seconds)</li>
</ul>
<p >The synchronized clock is very convenient when thing have to happen more or less simultaneously in the network. Note that this clock is not mean to be synchronized on a subsecond resolution. It can for example be used to coordinate iBeacon major or minor updates.</p>
<h1><a class="anchor" id="autotoc_md58"></a>
Background</h1>
<p >For more background on the data structures defined for our advertisements and scan responses see our <a class="el" href="md_docs_protocol_PROTOCOL.html">protocol</a> and <a class="el" href="md_docs_protocol_SERVICE_DATA.html">service data</a> documents. As a quick reminder these are the possible data types for advertisement (AD) or scan response (SRD) payloads (see also <a href="https://www.bluetooth.com/specifications/assigned-numbers/generic-access-profile/">bluetooth sig</a>):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">value   </th><th class="markdownTableHeadNone">type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x01   </td><td class="markdownTableBodyNone">flags (actually only in AD)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x02   </td><td class="markdownTableBodyNone">service UUIDs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">...   </td><td class="markdownTableBodyNone">...    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x07   </td><td class="markdownTableBodyNone">service UUIDs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x08   </td><td class="markdownTableBodyNone">shortened local name    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x09   </td><td class="markdownTableBodyNone">complete local name    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x0A   </td><td class="markdownTableBodyNone">tx level    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x12   </td><td class="markdownTableBodyNone">slave connection interval range    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x14   </td><td class="markdownTableBodyNone">sollicitation UUIDs    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x15   </td><td class="markdownTableBodyNone">sollicitation UUIDs    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x16   </td><td class="markdownTableBodyNone">service data    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x17   </td><td class="markdownTableBodyNone">public target address    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x18   </td><td class="markdownTableBodyNone">random target address    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x19   </td><td class="markdownTableBodyNone">appearance    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x1A   </td><td class="markdownTableBodyNone">advertising interval    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x24   </td><td class="markdownTableBodyNone">URI    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x25   </td><td class="markdownTableBodyNone">indoor positioning    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x27   </td><td class="markdownTableBodyNone">supported features    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x29   </td><td class="markdownTableBodyNone">mesh provisioning over advertising    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0x2A   </td><td class="markdownTableBodyNone">mesh message    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0x2B   </td><td class="markdownTableBodyNone">mesh beacon    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">0xFF   </td><td class="markdownTableBodyNone">manufacturer specific data   </td></tr>
</table>
<p >Remark, we do not use the indoor positioning service (<a href="https://www.bluetooth.com/specifications/specs/indoor-positioning-service-1-0/">specification</a>). It contains fields like floor number, altitude, uncertainty, latitude, and longitude as if indoor positioning is just a form of global positioning.</p>
<p >Like you see from this table of accepted advertisement data fields is that <code>0x2A</code>, a mesh message, or <code>0x2B</code>, a mesh beacon, are just legacy Bluetooth LE advertisements. You will see them on e.g. a smartphone app that scans for advertisements (you will just not be able to decrypt them). There are multiple of those beacon types actually. An unprovisioned device beacon sends out its device <a class="el" href="classUUID.html" title="Class that enables the use of 128 bit service UUIDs.">UUID</a> and how to do the out-of-band (OOB) provisioning. A secure network beacon broadcasts the network ID, the IV index, and an authentication value.</p>
<h1><a class="anchor" id="autotoc_md59"></a>
Details</h1>
<p >There are many more elaborate features. It is for example possible to have temporary guest access for a node. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
